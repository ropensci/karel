[{"path":"https://ropensci.github.io/karel/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to karel","title":"Contributing to karel","text":"outlines propose change karel. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"https://ropensci.github.io/karel/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to karel","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://ropensci.github.io/karel/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to karel","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"https://ropensci.github.io/karel/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to karel","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"mpru/karel\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://ropensci.github.io/karel/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to karel","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://ropensci.github.io/karel/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to karel","text":"Please note karel project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"some-ideas-about-programming","dir":"Articles","previous_headings":"","what":"Some Ideas about Programming","title":"1 - Introduction and programming basics","text":"Computers essential part daily lives. Almost devices use type computer capable performing certain tasks: washing machines different washing modes, gaming consoles entertainment, powerful calculators, personal computers used various purposes, cell phones countless applications, many . devices different types computers something common: someone “tells ” work, , provide set instructions follow order accomplish task. ’s programming : activity people give computer set instructions solve problem. perform activity called programmers. Without people programming , computers cease useful, matter complex devices may . sets instructions computers receive called programs. Programming creative process: many cases, task can accomplished following different paths, programmer one must imagine paths choose one. paths may better others, case, computer simply follow instructions devised programmer. Unfortunately, computers don’t understand English human language. give instructions language can understand. , need learn programming language, simply artificial language composed series expressions computer can interpret. Computers interpret instructions literally, programming, need specific. must follow rules programming language clear instructions provided. Now, learn program want analyze data, generate statistics, graphs conclusions? activity statistical professionals, data science professionals, anyone requires data analysis enhanced use computer tools programming capabilities assist us different stages work, collection purification data sets, application different analysis methodologies, effective communication results. ’s tutorial, study basic concepts programming, fostering exercise abstract logical thinking necessary effectively communicate computer make perform tasks need. programming language used tutorial R, widely used field data science. However, must emphasize R tutorial, meaning focus learning tools language provides data analysis. incorporate basic programming notions, make use help Karel, robot lives walks rectangular worlds. ask Karel perform certain activities, , program R, Karel accompany us first steps take language. Karel Robot programming language created educational purposes Dr. R. E. Pattis Stanford University (California, USA), also wrote book Karel Robot: Gentle Introduction Art Programming 1981. name pays homage Karel Capek, Swedish writer invented word robot science fiction work R.U.R. (Rossum’s Universal Robots). syntax based Pascal, important programming language time. decades, teaching strategy used many places around world, implementing Karel different languages Java, C++, Ruby, Python. Many examples presented guide taken Karel robot learns Java (Eric Roberts). far know, Karel developed R. package first implementation, help us improve notifying us anything notice needs revision! delve playing Karel, let’s review concepts related Programming ’s good keep mind.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"problems-algorithms-and-programming-languages","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"Problems, algorithms, and programming languages","title":"1 - Introduction and programming basics","text":"mentioned earlier programming consists instructing computer solve problem, communication instructions must clear. ’s , faced problem needs solved computationally, first step think carefully can solved, words, create algorithm. algorithm consistent strategy ordered set steps leads us solution problem achievement goal. , translate chosen algorithm language computer. Therefore, can say computational resolution problem consists two basic stages: 1.Algorithmic design: develop algorithm, choose existing one, solves problem. 2. Coding: express algorithm programming language computer can interpret execute . learning programming, start facing simple problems first stage seems easy, coding becomes difficult learn rules programming language. However, practice can quickly gain ease writing code, algorithmic design becomes challenging tackle complex problems. ’s emphasize formulation development algorithms fundamental stage programming.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"algorithmic-design","dir":"Articles","previous_headings":"Some Ideas about Programming > Problems, algorithms, and programming languages","what":"Algorithmic Design","title":"1 - Introduction and programming basics","text":"faced problem, first step devise algorithm solution express writing, example, Spanish, adapting human language logical forms resemble tasks computer can perform. programming, artificial informal language developers use creating algorithms called pseudocode. tool use describe algorithms mixing common language programming instructions. programming language , meaning computer capable understanding . purpose pseudocode allow programmer focus logical solution use guide writing program. tutorial, providing examples pseudocode writing. However, important understand attempting program, essential think ahead plan algorithm, .e., steps required reach solution, jot paper pen devising strategy. can great aid process.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"coding","dir":"Articles","previous_headings":"Some Ideas about Programming > Problems, algorithms, and programming languages","what":"Coding","title":"1 - Introduction and programming basics","text":"algorithm presented pseudocode use terms taken Spanish language, reasonable choice sharing strategy among people communicate language. However, want present algorithm someone speaks French, Spanish longer good choice, let alone want present algorithm computer. order computer understand algorithm, need translate programming language, , mentioned , artificial language designed express computations can carried electronic devices; words, means communication humans machines. two types errors: logical syntactic. latter instructions variable names written correctly program “interpret” . Logic errors generated instructions program can interpret, things want. actions make algorithm encoded one several instructions, expressed chosen programming language, set constitutes program. program encoding saved plain text file identifier usually divided two parts dot, example: my_first_program.R. first part file name. second part indicative language can interpret instructions, example, .R indicates contains program written R language. general process writing modifying instructions file called editing.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"programming-errors","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"Programming Errors","title":"1 - Introduction and programming basics","text":"soon embark journey world programming, realize always certain companions: errors. Many times, try run code won’t work produce expected result. matter careful much experience , errors always present. time practice, able identify correct easily, probably never stop making . something discouraged , solving errors make often leads great learning experiences. Programming errors often called bugs, process correcting known debugging. said terminology dates back 1947 computer Harvard University (Mark II) stopped working, eventually discovered cause problem moth found one machine’s electromagnetic relays. However, historians argue term already use .","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"processor-environment-and-actions","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"Processor, Environment, and Actions","title":"1 - Introduction and programming basics","text":"defined algorithm list instructions solve problem. context, processor understood agent capable understanding steps algorithm executing work indicated . achieve objective, processor uses certain resources disposal. elements available used programmer constitute environment working environment. instructions make algorithm modify environment way called actions.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"r-and-rstudio","dir":"Articles","previous_headings":"Some Ideas about Programming","what":"R and RStudio","title":"1 - Introduction and programming basics","text":"mentioned earlier, put practice programming concepts using R. Unlike many languages, R free open-source software distributed GNU GPLv2 license, allows freedom use purpose, see made, works, modify , distribute copies, create contributions additions available others. Although R means communication computer, use another program provides tools facilitate programming work. words, use integrated development environment (IDE). IDE program makes coding easier allowing us manage multiple code files, visualize working environment, use color highlighting different parts code, employ autocomplete write faster, explore help pages, implement debugging strategies, even interactively execute instructions viewing results progress analyzing solving problem. popularly used IDE programming R RStudio, program ’ll using time. install programs, visit official websites R RStudio, download installers, run . can find complete installation guide link.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"organization-of-rstudio","dir":"Articles","previous_headings":"Some Ideas about Programming > R and RStudio","what":"Organization of RStudio","title":"1 - Introduction and programming basics","text":"open RStudio, see four panels: Captura de pantalla de RStudio left: top file editor. write edit programs, save . first time open RStudio installation, panel may present, appears go File > New File > R Script, use shortcut Ctrl + Shift + N, click first icon toolbar. can open multiple files . console. console interactive environment R user. console, send instructions R evaluation (also known running executing ), results displayed . top-right corner, panel several tabs: Environment (environment): shows elements created current work session, make environment. History: lists instructions user executed. tabs relevant now. bottom-right corner, another panel additional tabs: Files: file explorer computer. Plots: window graphics appear code produces . Packages: tool installing, updating loading R packages (later talk “packages” ). Help: help manual covering functions R. Viewer: space view program outputs dynamic interactive components.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"using-the-console","dir":"Articles","previous_headings":"Some Ideas about Programming > R and RStudio","what":"Using the Console","title":"1 - Introduction and programming basics","text":"can use R console found left panel enter instructions , press Enter, evaluated, producing results. example, can perform mathematical calculations division, multiplication, addition, subtraction, exponentiation, logarithms, square roots, : block lines starting > represent code written user console. result shown cases lines start [1], something can ignore moment. can write instructions console press Enter execute , generally, want write save code file. ’s write programs top-left panel. write instruction script, can run (.e., send console execution) clicking Run button using shortcut Ctrl + Enter. way, line cursor selected lines run. every programming language, special character , placed beginning code line, tells software line evaluated. used include comments, lines express explanations clarifications natural language others may use code. Comments also used add headers descriptions script indicate different sections parts program. R, special character number symbol (#). run lines begin #, R ignore skip . example:","code":"> 1 + 2 [1] 3 > 5 * 3 [1] 15 > exp(2) [1] 7.389056 > sqrt(100) [1] 10 > 1 / 0 [1] Inf > (2 + 3i) * (3 + 6i) [1] -12+21i > 1i ^ 2 [1] -1+0i > 5^1 [1] 5 > # 5^2   this is not evaluated > 5^3 [1] 125"},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_en.html","id":"r-system-design","dir":"Articles","previous_headings":"Some Ideas about Programming > R and RStudio","what":"R System Design","title":"1 - Introduction and programming basics","text":"R divided two parts: base (R Base), installed download program CRAN (Comprehensive R Archive Network). contains, among things, set basic fundamental tools R. Additional packages. package set files can optionally downloaded CRAN repositories used perform specific tasks. example, work Karel, need install package contains implementation, called karel. mentioned earlier, Packages tab bottom-right panel displays list packages already installed (many come R Base). also button install new packages CRAN. Alternatively, can run command install.packages(\"packagename\") install package: also possible install packages published repositories. example, common download packages development experimentation available GitHub platform. packages can installed specifying GitHub account name package author package name. want install development version karel package (necessary), following: package installed , every time want use , need load tools become available us. done library(\"packagename\") command, example, library(\"karel\").","code":"> # Instalar desde CRAN el paquete karel > install.packages(\"karel\") > # Instalar desde CRAN el paquete devtools > install.packages(\"devtools\") > # Instalar desde GitHub el paquete karel > devtools::install_github(\"ropensci/karel\")"},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"algunas-ideas-sobre-programación","dir":"Articles","previous_headings":"","what":"Algunas ideas sobre Programación","title":"1 - Introducción y nociones básicas","text":"Podés encontrar una versión más extensa de esta introducción en esta Guía de Estudio. Las computadoras son una parte esencial de nuestra vida cotidiana. Casi todos los aparatos que usamos tienen algún tipo de computadora capaz de ejecutar ciertas tareas: lavarropas con distintos modos de lavado, consolas de juegos para momentos de entretenimiento, calculadoras súper potentes, computadoras personales que se usan para un montón de propósitos, teléfonos celulares con un sinfín de aplicaciones y miles de cosas más. Todos estos dispositivos con computadoras de distinto tipo tienen algo en común: alguien “les dice” cómo funcionar, es decir, les indica cuáles son los pasos que deben seguir para cumplir una tarea. De eso se trata la programación: es la actividad mediante la cual las personas le entregan una computadora un conjunto de instrucciones para que, al ejecutarlas, ésta pueda resolver un problema. Quienes realizan esta actividad reciben el nombre de programadores. Sin las personas que las programen, las computadoras dejan de ser útiles, por más complejos que sean estos aparatos. Los conjuntos de instrucciones que reciben las computadoras reciben el nombre de programas. La programación es un proceso creativo: en muchas ocasiones la tarea en cuestión puede cumplirse siguiendo distintos caminos y el programador es el que debe imaginar cuáles son y elegir uno. Algunos de estos caminos pueden ser mejores que otros, pero en cualquier caso la computadora se limitará seguir las instrucciones ideadas por el programador. Desafortunadamente, las computadoras entienden español ni otro idioma humano. Hay que pasarles las instrucciones en un lenguaje que sean capaces de entender. Para eso debemos aprender algún lenguaje de programación, que es más que un lenguaje artificial compuesto por una serie de expresiones que la computadora puede interpretar. Las computadoras interpretan nuestras instrucciones de forma muy literal, por lo tanto la hora de programar hay que ser muy específicos. Es necesario respetar las reglas del lenguaje de programación y ser claros en las indicaciones provistas. Ahora bien, ¿por qué debemos aprender programar cuando queremos analizar datos, generar estadísticas, gráficas y conclusiones? La actividad de los profesionales estadísticos, de ciencia de Datos, o cualquier persona que requiera hacer análisis de datos se potencia con el manejo de herramientas informáticas y capacidades de programación que nos asisten en las distintas etapas de nuestra labor, desde la recolección y depuración de conjuntos de datos, pasando por la aplicación de distintas metodologías de análisis, hasta la comunicación efectiva de los resultados. Por eso, en este tutorial estudiaremos conceptos básicos de programación, fomentando la ejercitación del pensamiento abstracto y lógico necesario para poder entendernos hábilmente con la computadora y lograr que la misma realice las tareas que necesitamos. El lenguaje de programación en el que se basa este tutorial es R, ampliamente empleado en el ámbito de la ciencia de datos. Sin embargo, debemos resaltar que éste es un tutorial sobre R, es decir, nos dedicaremos aprender las herramientas que este lenguaje brinda para el análisis de datos. Para incorporar algunas nociones básicas de programación vamos valernos de la ayuda de Karel, una robot que vive y camina por mundos rectangulares. Vamos pedirle Karel que realice ciertas actividades y para esto tenemos que programar en R, de modo que Karel nos acompañará en los primeros pasos que demos con este lenguaje. Karel Robot es un lenguaje de programación creado con fines educativos por el Dr. R. E. Pattis de la Universidad de Stanford (California, EEUU), quien también escribió el libro Karel Robot: Gentle Introduction Art Programming en 1981. Su nombre es un homenaje Karel Capek, el escritor sueco que inventó la palabra robot en su obra de ciencia ficción R.U.R. (Rossum’s Universal Robots). Su sintaxis se basaba en Pascal, un lenguaje de programación muy importante en aquellos tiempos. lo largo de las décadas, esta estrategia de enseñanza fue utilizada en muchos lugares alrededor del mundo, implementando Karel en distintos lenguajes como Java, C++, Ruby y Python. Muchos de los ejemplos presentados en esta guía fueron tomados de Karel robot learns Java (Eric Roberts, 2005). Hasta donde sabemos, Karel había sido desarrollado en R. Nuestro paquete es la primera implementación, ¡ayudanos mejorarlo avisándonos cualquier cosa que notes que necesite revisión! Pero antes de meternos de lleno jugar con Karel, vamos repasar algunos conceptos relativos la Programación que viene bien tener presente.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"problemas-algoritmos-y-lenguajes-de-programación","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"Problemas, algoritmos y lenguajes de programación","title":"1 - Introducción y nociones básicas","text":"Mencionamos anteriormente que la programación consistía en instruir una computadora para que resuelva un problema y que la comunicación de esas instrucciones debe ser realizada de forma clara. Es por eso que, ante un problema que debe ser resuelto computacionalmente, el primer paso es pensar detalladamente cuál puede ser una forma de resolverlo, es decir, crear un algoritmo. Un algoritmo es una estrategia consistente de un conjunto ordenado de pasos que nos lleva la solución de un problema o alcance de un objetivo. Luego, hay que traducir el algoritmo elegido al idioma de la computadora. Entonces, podemos decir que la resolución computacional de un problema consiste de dos etapas básicas: Diseño algorítmico: desarrollar un algoritmo, o elegir uno existente, que resuelva el problema. Codificación: expresar un algoritmo en un lenguaje de programación para que la computadora lo pueda interpretar y ejecutar. Al aprender sobre programación, comenzamos enfrentándonos problemas simples para los cuales la primera etapa parece sencilla, mientras que la codificación se torna dificultosa ya que hay que aprender las reglas del lenguaje de programación. Sin embargo, mientras que con práctica rápidamente podemos ganar facilidad para la escritura de código, el diseño algorítmico se torna cada vez más desafiante al encarar problemas más complejos. Es por eso que haremos hincapié en el planteo y desarrollo de algoritmos como una etapa fundamental en la programación.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"el-diseño-algorítmico","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > Problemas, algoritmos y lenguajes de programación","what":"El diseño algorítmico","title":"1 - Introducción y nociones básicas","text":"Frente cada problema, el primer paso es idear un algoritmo para su solución y expresarlo por escrito, por ejemplo, en español, pero adaptando el lenguaje humano formas lógicas que se acerquen las tareas que puede realizar una computadora. En programación, el lenguaje artificial e informal que usan los desarrolladores en la confección de algoritmos recibe el nombre de pseudocódigo. Es la herramienta que utilizamos para describir los algoritmos mezclando el lenguaje común con instrucciones de programación. es en sí mismo un lenguaje de programación, es decir, la computadora es capaz de entenderlo, sino que el objetivo del mismo es que el programador se centre en la solución lógica y luego lo utilice como guía al escribir el programa. En este tutorial vamos estar presentando ejemplos de escritura con pseudocódigo. Sin embargo, tenemos que tener en claro que antes de intentar programar, es importante pensar con anticipación el algoritmo, es decir, todos los pasos para llegar la solución y anotarlos en papel y birome mientras ideamos una estrategia puede ser una gran ayuda.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"codificación","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > Problemas, algoritmos y lenguajes de programación","what":"Codificación","title":"1 - Introducción y nociones básicas","text":"Un algoritmo presentado en pseudocódigo podría utilizar términos tomados del lenguaje español, una opción razonable para compartir esta estrategia entre personas que se comuniquen con este idioma. Claramente, si queremos presentarle nuestro algoritmo alguien que sólo habla francés, el español ya sería una buena elección y mucho menos si queremos presentarle el algoritmo una computadora. Para que una computadora pueda entender nuestro algoritmo, debemos traducirlo en un lenguaje de programación, que, como dijimos antes, es un idioma artificial diseñado para expresar cómputos que puedan ser llevados cabo por equipos electrónicos, es decir es un medio de comunicación entre el humano y la máquina. Cada una de las acciones que componen al algoritmo son codificadas con una o varias instrucciones, expresadas en el lenguaje de programación elegido, y el conjunto de todas ellas constituye un programa. La codificación del programa se guarda en un archivo de texto plano con un identificador generalmente dividido en dos partes por un punto, por ejemplo: mi_primer_programa.R. La primera parte es el nombre del archivo. La segunda parte es indicativa del lenguaje que puede interpretar las instrucciones, por ejemplo, .R indica que contiene un programa escrito en el lenguaje R. El proceso general de escribir o modificar las instrucciones en un archivo se denomina edición.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"errores-de-programación","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"Errores de programación","title":"1 - Introducción y nociones básicas","text":"Apenas iniciemos nuestro camino en el mundo de la programación nos daremos cuenta que tendremos siempre ciertos compañeros de viaje: los errores. Muchas veces nos pasará que queremos ejecutar nuestro código y el mismo anda o produce el resultado esperado. importa cuán cuidadosos seamos, ni cuánta experiencia tengamos, los errores están siempre presentes. Con el tiempo y práctica, vamos poder identificarlos y corregirlos con mayor facilidad, pero probablemente nunca dejemos de cometerlos. Esto es para amargarse, puesto que través de la solución de los errores cometidos muchas veces se producen grandes aprendizajes. Hay dos tipos de errores: los lógicos y los sintácticos. Estos últimos tienen que ver cuándo las instrucciones, o nombres de variables son correctamente escritos y el programa puede “interpretarlos”. Los errores lógicos se generan con instrucciones que el programa puede interpretar, pero que realizan cosas que queremos. los errores en programación se los suele llamar bugs (insecto o bicho en inglés) y el proceso de la corrección de los mismos se conoce como debugging (depuración)1. Se dice que esta terminología proviene de 1947, cuando una computadora en la Universidad de Harvard (la Mark II) dejó de funcionar y finalmente se descubrió que la causa del problema era la presencia de una polilla en un relé electromagnético de la máquina. Sin embargo, otros historiadores sostienen que el término ya se usaba desde antes.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"procesador-ambiente-y-acciones","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"Procesador, ambiente y acciones","title":"1 - Introducción y nociones básicas","text":"Hemos definido un algoritmo como una lista de instrucciones para resolver un problema. En este contexto, se entiende por procesador todo agente capaz de comprender los pasos de un algoritmo y ejecutar el trabajo indicado por el mismo. Para cumplir con el objetivo, el procesador emplea ciertos recursos que tiene disposición. Todos los elementos disponibles para ser utilizados por el programador constituyen el entorno o ambiente de trabajo. Cada una de las instrucciones que componen el algoritmo modifican el entorno de alguna manera y se denominan acciones.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"r-y-rstudio","dir":"Articles","previous_headings":"Algunas ideas sobre Programación","what":"R y RStudio","title":"1 - Introducción y nociones básicas","text":"Como dijimos anteriormente, pondremos en práctica los conceptos sobre programación utilizando R. diferencia de muchos otros, este es un software libre y gratuito: se distribuye bajo la licencia GNU GPLv2 que establece la libertad de usarlo con cualquier propósito, de ver cómo fue hecho, cómo funciona y modificarlo, de distribuir copias y crear contribuciones y agregados para que estén disponibles para otros 2. Si bien R será nuestro medio de comunicación con la computadora, vamos usar otro programa que brinda algunas herramientas para facilitar nuestro trabajo de programación, es decir, vamos usar un entorno de desarrollo integrado (o IDE, por integrated development environment). Un IDE es un programa que hace que la codificación sea más sencilla porque permite manejar varios archivos de código, visualizar el ambiente de trabajo, utilizar resaltado con colores para distintas partes del código, emplear autocompletado para escribir más rápido, explorar páginas de ayuda, implementar estrategias de depuración e incluso intercalar la ejecución de instrucciones con la visualización de los resultados mientras avanzamos en el análisis o solución del problema. El IDE más popularmente empleado para programar con R es RStudio y será el programa que estaremos usando todo el tiempo. Para instalar estos programas, se debe visitar las páginas oficiales de R y de RStudio, descargar los instaladores y ejecutarlos. En este enlace se presenta un video con la instalación completa.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"organización-de-rstudio","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > R y RStudio","what":"Organización de RStudio","title":"1 - Introducción y nociones básicas","text":"Cuando se abre RStudio se pueden visualizar cuatro paneles: Captura de pantalla de RStudio la izquierda: Arriba está el editor de archivos. Es el lugar donde escribiremos y editaremos nuestros programas, para luego guardarlos. La primera vez que se abre RStudio después de su instalación puede ser que este panel esté presente, pero aparece si vamos File > New File > R Script, con el atajo Ctrl + Shift + N o haciendo clic en el primer ícono de la barra de herramientas. Podemos abrir varios archivos la vez. Abajo está la consola. La consola es el ambiente interactivo entre R y el usuario. través de ella se envían las instrucciones R para que las evalúe (también decimos, que las ejecute o corra) y se visualizan los resultados. Arriba la derecha hay un panel con algunas pestañas: Environment (ambiente): muestra los elementos creados en la sesión de trabajo presente, que conforman al ambiente o entorno. History (historial): lista todas las instrucciones que el usuario ha ejecutado. Otras más que nos interesan por ahora. Abajo la derecha hay otro panel con más pestañas: Files: explorador de archivos de la computadora. Plots: ventana donde aparecen los gráficos si es que nuestro código produce alguno. Packages: herramienta de instalación, actualización y carga de los paquetes de R (más adelante mencionaremos esto de los “paquetes” otra vez). Help: manual de ayuda sobre todas las funciones de R. Viewer: espacio para ver salidas de los programas con algún componente dinámico o interactivo.","code":""},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"uso-de-la-consola","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > R y RStudio","what":"Uso de la consola","title":"1 - Introducción y nociones básicas","text":"Podemos usar la consola de R que encontramos en el panel de la izquierda para introducir allí nuestras instrucciones y al hacer Enter serán evaluadas, produciendo algún resultado. Por ejemplo, podemos hacer algunos cálculos matemáticos como dividir, multiplicar, sumar, restar, calcular potencias, logaritmos, raíces y mucho más: En el cuadro anterior las líneas que comienzan con > representan código escrito por el usuario en la consola. El resultado se muestra debajo y en estos casos son líneas que empiezan con [1], algo que por el momento podemos ignorar. Si bien podemos escribir nuestras instrucciones en la consola y dar Enter para que se ejecuten, en general queremos que queden escritas y guardadas en el archivo de código, por eso vamos escribir nuestros programas en el panel de arriba la izquierda. Una vez que escribimos una instrucción en el script, podemos correrla (es decir, enviarla la consola para que se ejecute) haciendo clic en el ícono Run o con el atajo Ctrl + Enter. De esta forma, se corre la línea en la cual está el cursor o las líneas que hayamos seleccionado. En todo lenguaje de programación existe un caracter especial que, al ser colocado al comienzo de una línea de código, le indica al software que dicha línea debe ser evaluada. Esto se utiliza para incluir comentarios, es decir, líneas que expresan en español explicaciones o aclaraciones para nosotros mismos u otros que puedan utilizar nuestro código. También se utiliza para añadir encabezados con descripciones sobre el script, o indicar distintas secciones o partes en el programa. En R, este caracter especial es el símbolo numera (#). Si corremos líneas que empiezan con #, R hará nada con ellas, las salteará. Por ejemplo","code":"> 1 + 2 [1] 3 > 5 * 3 [1] 15 > exp(2) [1] 7.389056 > sqrt(100) [1] 10 > 1 / 0 [1] Inf > (2 + 3i) * (3 + 6i) [1] -12+21i > 1i ^ 2 [1] -1+0i > 5^1 [1] 5 > # 5^2    esto no se evalúa > 5^3 [1] 125"},{"path":"https://ropensci.github.io/karel/articles/a_intro_progrbasics_es.html","id":"diseño-del-sistema-r","dir":"Articles","previous_headings":"Algunas ideas sobre Programación > R y RStudio","what":"Diseño del sistema R","title":"1 - Introducción y nociones básicas","text":"R se divide en dos partes: La base (R Base), que se instala cuando descargamos el programa desde CRAN (“Comprehensive R Archive Network”). Contiene, entre otras cosas, una serie de herramientas básicas y fundamentales de R. Paquetes adicionales. Un paquete es un conjunto de archivos que se descarga de forma opcional desde CRAN u otros repositorios y que sirven para hacer alguna tarea especial. Por ejemplo, para poder jugar con Karel deberemos instalar el paquete que contiene su implementación, llamado karel. Como dijimos antes, en la pestaña Packages del panel de abajo la derecha tiene el listado de todos los paquetes que ya están instalados (muchos vienen con R Base). Allí también hay un botón para instalar nuevos desde CRAN, aunque otra opción es correr la instrucción install.packages(\"nombredelpaquete\"): También es posible instalar paquetes publicados en otros repositorios. Por ejemplo, es muy común descargar paquetes en desarrollo o en experimentación que estén disponibles en la plataforma Github. Estos paquetes se instalan especificando el nombre de la cuenta de Github de quien lo haya publicado y el nombre del paquete. Si queremos instalar la versión en desarrollo del paquete karel (es necesario) deberíamos hacer: Un paquete se instala una sola vez, pero cada vez que lo queramos usar debemos cargarlo para que las herramientas que trae queden nuestra disposición. Eso se hace con la instrucción library(\"nombredelpaquete\"), por ejemplo, library(\"karel\").","code":"> # Instalar desde CRAN el paquete karel > install.packages(\"karel\") > # Instalar desde CRAN el paquete devtools > install.packages(\"devtools\") > # Instalar desde GitHub el paquete karel > devtools::install_github(\"ropensci/karel\")"},{"path":"https://ropensci.github.io/karel/articles/aa_get_started_en.html","id":"who-is-karel","dir":"Articles","previous_headings":"","what":"Who is Karel?","title":"Get started with Karel the robot","text":"karel R package created purpose providing environment enables teaching programming principles dynamic interactive way, students previous experience studying secondary level early years undergraduate education. Karel robot lives walks certain worlds, can perform certain actions ask , learn program R. robot Karel assists teaching fundamental programming concepts, processor (Karel), environment (world), objects (called beepers), actions (activities can perform). addition, can seen examples tutorials presented page, along Karel, possible instruct concept algorithmic decomposition: numerous occasions, robot must fulfill objectives whose resolution requires breaking problem smaller parts, students must program function R. also facilitates exemplification use sequential code control structures, conditionals (() {} else {}), iterative structures (() {}, () {}). first step programming Karel generate world can move, using instruction generate_world(), specifying name world want use within parentheses. package includes predefined worlds, users can choose create new ones. Karel’s worlds rectangular, composed streets run horizontally (rows) vertical avenues (columns). Karel always located intersection street avenue (cell), facing one four possible directions: east, north, west, south. black borders represent walls Karel cross; can go around . Additionally, cells, one several beepers. Karel can traverse world picking placing beepers; picks , stores backpack keeps track many . Finally, Karel can perform following activities: move(), turn_left(), pick_beeper() (pick coso), put_beeper(). However, cleverly combining basic actions, new ones can created. example, function turn_right() can created making Karel turn left three times. Furthermore, Karel capable evaluating certain characteristics environment functions return logical value TRUE FALSE, example: front_is_clear() (front open), beepers_present() facing_south(). allows us condition actions Karel performs based certain aspects position world. code actions Karel must perform executed, function run_actions() must run, result can seen animation created ggplot gganimate packages. order overcome language barriers can make taking first steps learning programming challenging, karel package designed completely bilingual: functions version Spanish English (example, girar_izquierda() turn_left()), help manual pages website pages written languages. idea implementation package based Karel Robot, programming language created educational purposes Dr. R. E. Pattis Stanford University (California, USA), also wrote book Karel Robot: Gentle Introduction Art Programming 1981. name pays homage Karel Capek, Swedish writer coined word “robot” science fiction work R.U.R. (Rossum’s Universal Robots). syntax based Pascal, decades, teaching strategy implemented different languages Java, C++, Ruby, Python. package presented first implementation Karel R. examples included vignettes adaptations published Eric Roberts material Karel robot learns Java (2005).","code":""},{"path":"https://ropensci.github.io/karel/articles/aa_get_started_en.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Get started with Karel the robot","text":"can install karel CRAN: can also install development version GitHub:","code":"install.packages(\"karel\") # install.packages(\"devtools\") devtools::install_github(\"mpru/karel\")"},{"path":"https://ropensci.github.io/karel/articles/aa_get_started_en.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"Get started with Karel the robot","text":"Can write program Karel place beepers vertices diamond enclosed ?  Maybe like ?  Now Karel maze. Can make reach end?  Yes, code:  can see details examples others tutorials section.","code":"> # Load the package and Karel's superpowers > library(karel) > load_super_karel() >  > # Create new functions > walk_diagonal <- function() { +   while (front_is_clear()) { +       move() +       turn_left() +       move() +       turn_right() +   } + } >  > # Solve the problem > generate_world(\"mundo019\") > for (i in 1:4) { +   walk_diagonal() +   put_beeper() +   turn_right() + } > run_actions() > generate_world(\"mundo009\") > while (no_beepers_present()) { +   turn_right() +   while (front_is_blocked()) { +     turn_left() +   } +   move() + } > run_actions()"},{"path":"https://ropensci.github.io/karel/articles/aa_get_started_es.html","id":"quién-es-karel","dir":"Articles","previous_headings":"","what":"¿Quién es Karel?","title":"Primeros pasos con la robot Karel","text":"karel es un paquete de R creado con el propósito de brindar un entorno que posibilite la enseñanza de principios de la programación en una forma dinámica e interactiva, para estudiantes sin experiencia previa que estén cursando el nivel secundario o los primeros años de su formación de grado. Karel es una robot que vive y camina por ciertos mundos, en los cuales puede realizar determinadas acciones si se lo pedimos, mientras aprendemos programar en R. La robot Karel acompaña en la enseñanza de conceptos fundamentales de la programación, por ejemplo, el de procesador (Karel), ambiente (su mundo), objetos (llamados cosos) y acciones (las actividades que puede realizar). Además, como se puede observar en los ejemplos de los tutoriales presentes en esta página, junto con Karel es posible instruir sobre el concepto de la descomposición algorítmica: en numerosas oportunidades la robot debe cumplir objetivos cuya resolución requiere descomponer el problema en partes más pequeñas, para cada una de las cuales los estudiantes deben programar una función en R. También facilita la ejemplificación del uso de estructuras de control de código secuenciales, condicionales (() {} else {}) e iterativas (() {}, () {}). El primer paso para programar con Karel es generar un mundo en el cual ella pueda andar, través de la instrucción generar_mundo(), aclarando entre los paréntesis el nombre del mundo que queremos usar. El paquete trae incorporados unos cuantos pero los usuarios pueden optar por crear otros nuevos. Todos los mundos de Karel son rectangulares, compuestos por calles que los recorren horizontalmente (filas) y avenidas verticales (columnas). Karel siempre se encuentra en la intersección entre una calle y una avenida (celda), mirando hacia una de las cuatro direcciones posibles: este, norte, oeste o sur. Los bordes negros representan paredes que Karel puede atravesar, solo puede rodearlas. Además, en algunas celdas hay uno o varios cosos. Karel puede recorrer el mundo poniendo y juntando cosos por ahí; si los junta los guarda en su mochila y lleva un registro de cuántos tiene. Finalmente, Karel solo puede realizar estas actividades: avanzar(), girar_izquierda(), juntar_coso() y poner_coso(). Claro, agrupando ingeniosamente estas acciones básicas se pueden crear otras nuevas, por ejemplo, crear una función girar_derecha() que produzca tal efecto, haciendo girar Karel tres veces la izquierda. Por otro lado, Karel es capaz de evaluar ciertas características de su entorno través de funciones que arrojan un valor lógico TRUE o FALSE, por ejemplo: frente_abierto(), hay_cosos() o mira_al_sur(), de manera que podemos condicionar las acciones que Karel realiza la verificación de ciertos aspectos sobre su posición y su mundo. Una vez que se ejecuta el código con todas las acciones que Karel debe realizar, se debe correr la función ejecutar_acciones() y se puede ver el resultado en una animación creada con los paquetes ggplot y gganimate. Con el objetivo de sortear algunas de las barreras idiomáticas que pueden hacer más desafiante poder dar los primeros pasos en el aprendizaje de programación, el paquete karel se diseñó de forma completamente bilingüe: todas las funciones tienen una versión en español y en inglés (por ejemplo,girar_izquierda() y turn_left()), así como también las páginas del manual de ayuda y algunas del sitio web están escritos en ambos idiomas. La idea para la implementación de este paquete se basa en Karel Robot, un lenguaje de programación creado con fines educativos por el Dr. R. E. Pattis de la Universidad de Stanford (California, EEUU), quien también escribió el libro Karel Robot: Gentle Introduction Art Programming, en 1981. Su nombre es un homenaje Karel Capek, el escritor sueco que inventó la palabra robot en su obra de ciencia ficción R.U.R. (Rossum’s Universal Robots). Su sintaxis se basaba en Pascal, pero lo largo de las décadas esta estrategia de enseñanza fue implementada en distintos lenguajes como Java, C++, Ruby y Python. El paquete aquí presentado es la primera implementación de Karel para R. Algunos de los ejemplos incluidos en las viñetas son adaptaciones de aquellos publicados por Eric Roberts en su material Karel robot learns Java (2005).","code":""},{"path":"https://ropensci.github.io/karel/articles/aa_get_started_es.html","id":"instalación","dir":"Articles","previous_headings":"","what":"Instalación","title":"Primeros pasos con la robot Karel","text":"Podés instalar karel desde CRAN: También podés instalar la versión en desarrollo desde GitHub:","code":"install.packages(\"karel\") # install.packages(\"devtools\") devtools::install_github(\"mpru/karel\")"},{"path":"https://ropensci.github.io/karel/articles/aa_get_started_es.html","id":"ejemplos","dir":"Articles","previous_headings":"","what":"Ejemplos","title":"Primeros pasos con la robot Karel","text":"¿Podés escribir un programa para que Karel coloque cosos en los vértices del rombo en en el cual está encerrada?  ¿Algo así, tal vez?  Ahora Karel está en un laberinto. ¿Podemos hacerla llegar hasta el final?  Sí, con este código:  Podés ver más detalles sobre estos ejemplos y otros en la sección de tutoriales.","code":"> # Cargar el paquete y los superpoderes de Karel > library(karel) > cargar_super_karel() >  > # Crear funciones auxiliares > recorrer_diagonal <- function() { +   while (frente_abierto()) { +       avanzar() +       girar_izquierda() +       avanzar() +       girar_derecha() +   } + } >  > # Implementar el problema > generar_mundo(\"mundo019\") > for (i in 1:4) { +   recorrer_diagonal() +   poner_coso() +   girar_derecha() + } > ejecutar_acciones() > generar_mundo(\"mundo009\") > while (no_hay_cosos()) { +   girar_derecha() +   while (frente_cerrado()) { +     girar_izquierda() +   } +   avanzar() + } > ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_en.html","id":"turning-right","dir":"Articles","previous_headings":"","what":"Turning right","title":"3 - Algorithmic decomposition","text":"start something simple, example seen previous section, Karel needed turn right, achieved telling turn left three times. bit inconvenient, firstly mentally imagine something else want Karel turn right, secondly Karel probably need turn right many problems, won’t want repeat turn_left() many times. ’s ’s reasonable create new function handle . Every time realize using sequence Karel commands accomplish specific task, turning right, time define new function encompasses commands: general, R, function created following steps: Choose name: girar_derecha (turn_right). Use assignment operator (arrow, <-) associate function definition name. Write instruction function() {...}, actions encompassed new function placed inside curly braces, one action per line: Using subalgorithm, can see code writing simplified. important note us able use turn_left() function, defined user evaluated R want use solve problem:  EXERCISE: Create function called turn_around() allows Karel make 180-degree turn face opposite direction.","code":"turn_right <- function() {   turn_left()   turn_left()   turn_left() } name <- function() {   ... R instructions ... } #  --------------- Load Karel package -------------------- library(karel)  # ------------ Definition of auxiliary functions -----------  turn_right <- function() {   turn_left()   turn_left()   turn_left() }  # ---------------- Main programa ----------------------  generate_world(\"mundo001\") move() pick_beeper() move() turn_left() move() put_beeper() move() move() put_beeper() move() run_actions()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_en.html","id":"karels-superpowers","dir":"Articles","previous_headings":"","what":"Karel’s superpowers","title":"3 - Algorithmic decomposition","text":"previous section, created turn_right() turn_around() functions learn generate new subalgorithms. However, streamline creation programs visualization Karel’s actions, R package provides enhanced versions turn_right() turn_around(). make available use, need activate Karel’s superpowers following statement, can executed time (library(karel) good place):","code":"library(karel) load_super_karel()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_en.html","id":"filling-the-hole","dir":"Articles","previous_headings":"","what":"Filling the hole","title":"3 - Algorithmic decomposition","text":"Let’s see another example usefulness algorithmic decomposition. happens many places, Karel’s world, streets sometimes need repair. Let’s imagine Karel walking street shown left figure encounters hole. task fill beeper move end, shown right figure.  limit Karel’s basic commands, program solve : However, use functions turn_right() turn_around(), program becomes shorter clearer: Now, filling hole can seen specific task can thought problem , can solved separately main algorithm. can define new subalgorithm specifically task, can reused situations. Following idea algorithmic decomposition, problem analyzing can decomposed follows:","code":"generate_world(\"mundo002\") move() turn_left() turn_left() turn_left() move() put_beeper() turn_left() turn_left() move() turn_left() turn_left() turn_left() move() run_actions() generate_world(\"mundo002\") move() turn_right() move() put_beeper() turn_around() move() turn_right() move() run_actions() #  --------------- Load Karel package --------------------  library(karel) load_super_karel() # makes turn_right() and turn_around() available  # ------------ Definition of auxiliary functions -----------  fill_hole <- function() {   turn_right()   move()   put_beeper()   turn_around()   move()   turn_right() }  # ------------------- Main program -------------------- generate_world(\"mundo002\") move() fill_hole() move() run_actions()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_en.html","id":"documentation-of-subalgorithms","dir":"Articles","previous_headings":"","what":"Documentation of subalgorithms","title":"3 - Algorithmic decomposition","text":"context programming, documentation means writing instructions people can understand want code use functions. example, saw earlier, predefined R functions documented can seek help needed. creating subalgorithms, important include comments guide people (future forget) developing. example, may good state name function clarify initial condition can used final result produces, example: examples presented tutorial adapted “Karel Robot Learns Java” Eric Roberts, published 2005.","code":"#  --------------- Load Karel package --------------------  library(karel) load_super_karel()  # ------------ Definition of auxiliary functions -----------  # Function: fill_hole # Initial condition: Karel is on top of the hole (on the previous street), # facing east # Final condition: Karel is in the same position as at the beginning and has # placed a beeper in the hole fill_hole <- function() {   turn_right()   move()   put_beeper()   turn_around()   move()   turn_right() }  # ------------------- Main program ------------------- generate_world(\"mundo002\") move() fill_hole() move() run_actions()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_es.html","id":"girar-a-la-derecha","dir":"Articles","previous_headings":"","what":"Girar a la derecha","title":"3 - Descomposición algorítmica","text":"Para empezar con algo sencillo, en el ejemplo visto en la sección anterior Karel necesitaba doblar la derecha y lo logramos indicándole que gire tres veces la izquierda. Esto es medio molesto, primero porque mentalmente nos imaginamos otra cosa cuando queremos que Karel gire la derecha y segundo porque probablemente Karel tenga que girar la derecha en muchos problemas y vamos querer repetir tantas veces girar_izquierda(). Por eso, es muy razonable crear una nueva función para que se encargue de esto. Cada vez que nos damos cuenta de que estamos usando una secuencia de comandos de Karel con el objetivo de cumplir una tarea específica, como doblar la derecha, entonces es momento de definir una nueva función que englobe esos comandos: De manera general, en R una función se crea con estos pasos: Elegir nombre: girar_derecha Usar el operador de asignación (o flechita, <-) para asociar ese nombre la definición de una función. Escribir la instrucción function() {...}, donde lo que va entre llaves es el conjunto de acciones que engloba la nueva función, una en cada renglón: Con la ayuda de este subalgoritmo, podemos apreciar cómo se simplifica la escritura del código. Es importante notar que, para que podamos usar la función girar_izquierda(), la misma tiene que ser definida por el usuario y evaluada por R antes de que queramos usarla para resolver nuestro problema:  EJERCICIO: crear una función llamada darse_vuelta() que le permita Karel realizar un giro de 180 grados y quedar mirando hacia la dirección contraria.","code":"girar_derecha <- function() {   girar_izquierda()   girar_izquierda()   girar_izquierda() } nombre <- function() {   ... instrucciones de R ... } #  --------------- Cargar paquete Karel -------------------- library(karel)  # ------------ Definición de funciones auxiliares-----------  girar_derecha <- function() {   girar_izquierda()   girar_izquierda()   girar_izquierda() }  # ---------------- Programa principal ----------------------  generar_mundo(\"mundo001\") avanzar() juntar_coso() avanzar() girar_izquierda() avanzar() girar_derecha() avanzar() avanzar() poner_coso() avanzar() ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_es.html","id":"los-superpoderes-de-karel","dir":"Articles","previous_headings":"","what":"Los superpoderes de Karel","title":"3 - Descomposición algorítmica","text":"En la sección anterior hemos creado las funciones girar_derecha() y darse_vuelta() por nuestros propios medios para aprender cómo generar nuevos subalgoritmos. Sin embargo, para agilizar la creación de nuestros programas y la visualización de lo que hace Karel, el paquete de R trae incorporadas mejores versiones de girar_derecha() y darse_vuelta(). Para que estén disponibles y las podamos usar, tenemos que activar estos superpoderes de Karel con la siguiente sentencia, que puede ser ejecutada en cualquier momento (luego de library(karel) sería un buen lugar):","code":"library(karel) cargar_super_karel()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_es.html","id":"llenar-el-agujero","dir":"Articles","previous_headings":"","what":"Llenar el agujero","title":"3 - Descomposición algorítmica","text":"Veamos otro ejemplo sobre la utilidad de la descomposición algorítmica. Como ocurre en muchos lugares, en el mundo de Karel veces las calles necesitan reparación. Imaginemos que Karel está caminando por la calle como se ve en la figura de la izquierda y se encuentra con un agujero. Su tarea es rellenarlo con un coso y avanzar hasta el otro extremo, como se ve en la figura de la derecha.  Si nos limitamos los comandos básicos de Karel, el programa que permite resolver esto es: Si en cambio usamos nuestras propias funciones girar_derecha() y darse_vuelta(), el programa queda más corto y claro: Ahora bien, el proceso de llenar el agujero es una tarea muy concreta que puede ser pensada como un problema en sí mismo, que se puede resolver por fuera del algoritmo principal. Podemos definir un nuevo subalgoritmo que se encargue específicamente de esto y que pueda ser reutilizado en otras ocasiones. Siguiendo entonces la idea de la descomposición algorítmica, el problema que estamos analizando puede ser descompuesto de esta forma:","code":"generar_mundo(\"mundo002\") avanzar() girar_izquierda() girar_izquierda() girar_izquierda() avanzar() poner_coso() girar_izquierda() girar_izquierda() avanzar() girar_izquierda() girar_izquierda() girar_izquierda() avanzar() ejecutar_acciones() generar_mundo(\"mundo002\") avanzar() girar_derecha() avanzar() poner_coso() darse_vuelta() avanzar() girar_derecha() avanzar() ejecutar_acciones() #  --------------- Cargar paquete Karel --------------------  library(karel) cargar_super_karel() # pone a disposición girar_derecha() y darse_vuelta()  # ------------ Definición de funciones auxiliares-----------  llenar_agujero <- function() {   girar_derecha()   avanzar()   poner_coso()   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal -------------------- generar_mundo(\"mundo002\") avanzar() llenar_agujero() avanzar() ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/c_decomposition_es.html","id":"documentación-de-los-subalgoritmos","dir":"Articles","previous_headings":"","what":"Documentación de los subalgoritmos","title":"3 - Descomposición algorítmica","text":"En el contexto de la programación, documentar significa escribir indicaciones para que otras personas puedan entender lo que queremos hacer en nuestro código o para que sepan cómo usar nuestras funciones. Por ejemplo, como vimos antes todas funciones predefinidas de R están documentadas para que podamos buscar ayuda si la necesitamos. Cuando estamos creando nuestras propios subalgoritmos, es importante que también incluyamos comentarios para guiar otras personas (y nosotros mismos en el futuro si nos olvidamos) para qué y cómo se usa lo que estamos desarrollando. Por ejemplo, puede ser bueno que enunciemos el nombre de la función y aclaremos bajo qué condición inicial se puede utilizar y qué resultado final arroja, por ejemplo: Algunos ejemplos presentados en este tutorial fueron adaptados de Karel robot learns Java (Eric Roberts, 2005).","code":"#  --------------- Cargar paquete Karel --------------------  library(karel) cargar_super_karel()  # ------------ Definición de funciones auxiliares-----------  # Función: llenar_agujero # Condición inicial: Karel se encuentra sobre el agujero (en la calle anterior), # mirando al este # Condición final: Karel se encuentra en la misma posición que al inicio y ha # colocado un coso en el agujero llenar_agujero <- function() {   girar_derecha()   avanzar()   poner_coso()   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal ------------------- generar_mundo(\"mundo002\") avanzar() llenar_agujero() avanzar() ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"sequential-control-structures","dir":"Articles","previous_headings":"","what":"Sequential Control Structures","title":"4 - Control structures","text":"Sequential control structures composed defined number actions placed specific order executed one another. examples discussed earlier formed type structure.","code":""},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"conditional-control-structures","dir":"Articles","previous_headings":"","what":"Conditional Control Structures","title":"4 - Control structures","text":"certain parts algorithm, may useful pause ask question reached situation may one options available continue. Depending answer question, must always TRUE FALSE, algorithm follow certain actions ignore others. questions answers represent decision-making processes lead different paths within algorithm, allowing solution problem hand flexible adapt different situations. types control structures called conditional (selection structures) can simple, double, multiple.","code":""},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"simple-conditional-structures","dir":"Articles","previous_headings":"Conditional Control Structures","what":"Simple Conditional Structures","title":"4 - Control structures","text":"involve logical evaluation, result TRUE, actions delimited braces define body structure executed. expressed R following syntax: word indicates logical evaluation command, condition indicates evaluation performed, instructions executed condition met, , evaluation results TRUE, detailed curly braces. condition satisfied, action executed, program continues sequential structure code follows last curly brace. Karel going help us illustrate . following table shows logical evaluations robot can perform world. example, execute function front_is_clear(), get value TRUE indeed wall front Karel, value FALSE wall. can use conditional structure modify fill_hole() function created earlier Karel places item wasn’t already one hole: Note although use indentation code optional, decided use improve readability. Maintaining clarity programs essential.","code":"if (condition) {     ...code to execute actions... } # ------------ Definition of auxiliary functions -----------  fill_hole <- function() {   turn_right()   move()   if (no_beepers_present()) {     put_beeper()   }   turn_around()   move()   turn_right() }  # ------------------- Main program -------------------  generate_world(\"mundo002\") move() fill_hole() run_actions()"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"double-conditional-structures","dir":"Articles","previous_headings":"Conditional Control Structures","what":"Double Conditional Structures","title":"4 - Control structures","text":"type conditional structure adds action executed case evaluated condition met (.e., returns FALSE). syntax : first set curly braces contains actions performed condition met, second set, following else statement, includes actions performed condition met. Let’s imagine want create algorithm reverse state cell, meaning Karel puts item isn’t one removes :  , can use double conditional structure:  Since repeat process checking whether item decide whether remove place one three times exactly way, can resort principle algorithmic decomposition define function takes care process, making action reversing state cell simpler. code file look like :","code":"if (condition) {     ...code to execute actions... } else {     ...code to execute actions... } generate_world(\"mundo001\") if (beepers_present()) {   pick_beeper() } else {   put_beeper() } move() if (beepers_present()) {   pick_beeper() } else {   put_beeper() } move() if (beepers_present()) {   pick_beeper() } else {   put_beeper() } run_actions() # ------------ Definition of auxiliary functions -----------  reverse_state <- function() {   if (beepers_present()) {     pick_beeper()   } else {     put_beeper()   } }  # ------------------- Main program -------------------  generate_world(\"mundo001\") reverse_state() move() reverse_state() move() reverse_state() run_actions()"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"multiple-or-nested-conditional-structures","dir":"Articles","previous_headings":"Conditional Control Structures","what":"Multiple or Nested Conditional Structures","title":"4 - Control structures","text":"structures allow combining multiple conditional structures establish complex controls flow actions, representing multiple decision-making points. can illustrate syntax follows: structure, initial logical evaluation , result TRUE, first set actions executed exclusively. Otherwise, result FALSE, second logical evaluation performed, leading execution either second third set actions, depending whether result TRUE FALSE, respectively.","code":"if (condition 1) {     ...First set of actions... } else if (condition 2) {     ...Second set of actions... } else {     ...Third set of actions... }"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"iterative-control-structures","dir":"Articles","previous_headings":"","what":"Iterative Control Structures","title":"4 - Control structures","text":"Iterative control structures useful solving problem requires repeatedly executing set actions. number times sequence actions needs repeated can fixed variable, depending data algorithm.","code":""},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"iterative-control-structures-with-a-fixed-number-of-iterations","dir":"Articles","previous_headings":"Iterative Control Structures","what":"Iterative Control Structures with a Fixed Number of Iterations","title":"4 - Control structures","text":"structures applied exact number times sequence actions needs repeated known advance. example, consider following problem holes evenly distributed even avenues.  need write program Karel fill 5 holes. plan something like : clear doesn’t make sense write exact code 5 times. Therefore, can use iterative structure: letter used represent number repetitions. example, sole purpose guide series steps. block instructions repeated many times takes reach 5 starting 1 (defined using 1:5 expression). chosen another letter another word instead, using quite common. general, syntax type structure :","code":"# ------------------- Main program -------------------  generate_world(\"mundo003\") move() fill_hole() move()  move() fill_hole() move()  move() fill_hole() move()  move() fill_hole() move()  move() fill_hole() move() run_actions() generate_world(\"mundo003\") for (i in 1:5) {   move()   fill_hole()   move() } run_actions() for (i in <initial_value>:<final_value>) {     ...Actions... }"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_en.html","id":"iterative-control-structures-with-an-indeterminate-number-of-iterations","dir":"Articles","previous_headings":"Iterative Control Structures","what":"Iterative Control Structures with an Indeterminate Number of Iterations","title":"4 - Control structures","text":"circumstances, may necessary repeat block actions without knowing exactly many times, rather depending aspect ALGORITHM. iterations can continue certain condition true. type structure, set instructions repeated long condition declared beginning block continues evaluate TRUE. condition longer met, process stops. syntax : Observations: evaluation condition takes place iteration, including first one. condition initially FALSE, actions body structure never executed. evaluation condition takes place beginning iteration. condition becomes FALSE point execution block, program notice block finishes executing condition evaluated starting next iteration. example, interesting write program fill holes like previous one works generally situations may number holes street, like :  Instead using loop specify number times process repeated, can use loop Karel keeps filling holes long wall front , indicating reached end stop. Care must taken writing type structure ensure infinite loop created, .e., iterative process never ends. occur, example, , previous world, ask Karel turn things standing: examples presented tutorial adapted “Karel robot learns Java” (Eric Roberts, 2005).","code":"while (<condition>) {     ...Actions to repeat... } # ------------------- Main program ------------------- generate_world(\"mundo003\") while (front_is_clear()) {   move()   fill_hole()   move() } run_actions() # Do not run this! (or do, to see how it doesn't work!) generate_world(\"mundo003\") while (no_beepers_present()) {     turn_left() } run_actions()"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-de-control-secuenciales","dir":"Articles","previous_headings":"","what":"Estructuras de control secuenciales","title":"4 - Estructuras de control del código","text":"Las estructuras secuenciales están compuestas por un número definido de acciones que se ubican en un orden específico y se suceden una tras otra. Los ejemplos que hemos discutido anteriormente están conformados por este tipo de estructura.","code":""},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-de-control-condicionales","dir":"Articles","previous_headings":"","what":"Estructuras de control condicionales","title":"4 - Estructuras de control del código","text":"En algunas partes de un algoritmo puede ser útil detenerse hacer una pregunta porque se llegó una situación en la que puede haber una o más opciones disponibles para continuar. Dependiendo de la respuesta la pregunta, que siempre deberá ser VERDADERO (TRUE) o FALSO (FALSE), el algoritmo seguirá ciertas acciones e ignorará otras. Estas preguntas y respuestas representan procesos de toma de decisión que conducen diferentes caminos dentro del algoritmo, permitiéndonos que la solución para el problema en cuestión sea flexible y se adapte distintas situaciones. Este tipo de estructuras de control de las acciones reciben el nombre de condicionales (o estructuras de selección) y pueden ser simples, dobles y múltiples.","code":""},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-condicionales-simples","dir":"Articles","previous_headings":"Estructuras de control condicionales","what":"Estructuras condicionales simples","title":"4 - Estructuras de control del código","text":"Postulan una evaluación lógica y, si su resultado es TRUE, se procede ejecutar las acciones delimitadas entre las llaves que definen el cuerpo de esta estructura. se expresan en R con la siguiente sintaxis: La palabra indica el comando de evaluación lógica, condición indica la evaluación realizar y entre llaves se detallas las instrucciones que se realizarán sólo si se cumple la condición, es decir, si la evaluación resulta en TRUE. Si la condición se verifica, se ejecuta ninguna acción y el programa sigue su estructura secuencial con el código que prosigue la última llave. Karel nos va ayudar ejemplificar esto. La siguiente tabla muestra las evaluaciones lógicas que la robot puede realizar acerca de su mundo. Por ejemplo, si ejecutamos la función frente_abierto(), obtendremos el valor TRUE si efectivamente hay una pared enfrente de Karel o el valor FALSE si hay una pared. Podemos usar una estructura condicional para modificar la función llenar_agujero() que creamos anteriormente para que Karel coloque un coso sólo si había ya uno presente en el agujero: Notar que si bien el uso de sangrías en el código es opcional, decidimos emplearlo para facilitar su lectura. Mantener la claridad en nuestros programas es esencial.","code":"if (condición) {     ...código para ejecutar acciones... } # ------------ Definición de funciones auxiliares-----------  llenar_agujero <- function() {   girar_derecha()   avanzar()   if (no_hay_cosos()) {     poner_coso()   }   darse_vuelta()   avanzar()   girar_derecha() }  # ------------------- Programa principal -------------------  generar_mundo(\"mundo002\") avanzar() llenar_agujero() ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-condicionales-dobles","dir":"Articles","previous_headings":"Estructuras de control condicionales","what":"Estructuras condicionales dobles","title":"4 - Estructuras de control del código","text":"Este tipo de estructura añade una acción ejecutarse en el caso de que la condición evaluada se verifique (es decir, devuelve el valor FALSE). La sintaxis es: Dentro del primer bloque de llaves se escriben las acciones que se realizan si se cumple la condición, mientras que en el segundo, luego de la expresión else, se incluyen las que se realizan si se verifica la misma. Imaginemos que queremos crear un algoritmo para revertir el estado de una celda, es decir, que Karel ponga un coso si hay o lo quite si es que hay:  Para esto podemos usar una estructura condicional doble:  Dado que repetimos 3 veces, exactamente de la misma forma, el proceso de controlar si hay o un coso para decidir quitarlo o poner uno, otra vez podemos recurrir al principio de la descomposición algorítmica y definir una función que se encargue de ellos, se forma que la acción de invertir el estado de una celda se haga de manera más sencilla. Nuestro archivo de código quedaría así:","code":"if (condición) {     ...código para ejecutar acciones... } else {     ...código para ejecutar acciones... } generar_mundo(\"mundo001\") if (hay_cosos()) {   juntar_coso() } else {   poner_coso() } avanzar() if (hay_cosos()) {   juntar_coso() } else {   poner_coso() } avanzar() if (hay_cosos()) {   juntar_coso() } else {   poner_coso() } ejecutar_acciones() # ------------ Definición de funciones auxiliares-----------  invertir <- function() {   if (hay_cosos()) {     juntar_coso()   } else {     poner_coso()   } }  # ------------------- Programa principal -------------------  generar_mundo(\"mundo001\") invertir() avanzar() invertir() avanzar() invertir() ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-condicionales-múltiples-o-anidadas","dir":"Articles","previous_headings":"Estructuras de control condicionales","what":"Estructuras condicionales múltiples o anidadas","title":"4 - Estructuras de control del código","text":"Permiten combinar varias estructuras condicionales para establecer controles más complejos sobre el flujo de las acciones, representando una toma de decisión múltiple. Podemos ejemplificar la sintaxis de la siguiente forma: En la estructura anterior, hay una primera evaluación lógica en la cual si el resultado es VERDADERO, se ejecuta el primer conjunto de acciones y nada más. En cambio, si su resultado es FALSO, se procede realizar una segunda evaluación lógica, que da lugar la ejecución del segundo o del tercer bloque de acciones, dependiendo de que su resultado sea VERDADERO o FALSO, respectivamente.","code":"if (condición 1) {     ...Primer conjunto de acciones... } else if (condición 2) {     ...Segundo conjunto de acciones... } else {     ...Tercer conjunto de acciones... }"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-de-control-iterativas","dir":"Articles","previous_headings":"","what":"Estructuras de control iterativas","title":"4 - Estructuras de control del código","text":"Las estructuras de control iterativas son útiles cuando la solución de un problema requiere que se ejecute repetidamente un determinado conjunto de acciones. El número de veces que se debe repetir dicha secuencia de acciones puede ser fijo o variable dependiendo de algún dato en el algoritmo.","code":""},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-de-control-iterativas-con-un-número-fijo-de-iteraciones","dir":"Articles","previous_headings":"Estructuras de control iterativas","what":"Estructuras de control iterativas con un número fijo de iteraciones","title":"4 - Estructuras de control del código","text":"Se aplican cuando se conoce de antemano el número exacto de veces que se debe repetir una secuencia de acciones. Por ejemplo, consideremos el siguiente problema donde hay agujeros distribuidos equiespaciadamente en las avenidas pares.  Tenemos que escribir un programa para que Karel llene los 5 agujeros. Podríamos planear algo como: Es evidente que tiene sentido escribir exactamente lo mismo 5 veces. Por eso vamos hacer uso de una estructura iterativa: La letra se usa para representar la cantidad de repeticiones. En este ejemplo, su única función es guiar la serie de pasos. El bloque de instrucciones se repite tantas veces como tarde en llegar 5 partiendo desde 1 (esto se define con un rango de valores en R usando la nomenclatura 1:5). Podríamos haber elegido otra letra u otra palabra en su lugar, pero emplear es bastante común. De manera general, la sintaxis para este tipo de estructuras es:","code":"# ------------------- Programa principal -------------------  generar_mundo(\"mundo003\") avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar()  avanzar() llenar_agujero() avanzar() ejecutar_acciones() generar_mundo(\"mundo003\") for (i in 1:5) {   avanzar()   llenar_agujero()   avanzar() } ejecutar_acciones() for (i in <valor_inicial>:<valor_final>) {     ...Acción/es... }"},{"path":"https://ropensci.github.io/karel/articles/d_controlstructures_es.html","id":"estructuras-de-control-iterativas-con-un-número-indeterminado-de-iteraciones","dir":"Articles","previous_headings":"Estructuras de control iterativas","what":"Estructuras de control iterativas con un número indeterminado de iteraciones","title":"4 - Estructuras de control del código","text":"En otras circunstancias se puede necesitar repetir un bloque de acciones sin conocer con exactitud cuántas veces, si que esto depende de algún otro aspecto del ALGORITMO. Las iteraciones pueden continuar mientras que se verifique alguna condición. En este tipo de estructuras, el conjunto de instrucciones se repite mientras que se siga evaluando como VERDADERO una condición declarada al inicio del bloque. Cuando la condición ya se cumple, el proceso deja de ejecutarse. La sintaxis es: Observaciones: La evaluación de la condición se lleva cabo antes de cada iteración, incluyendo la primera. Si la condición es FALSO inicialmente, entonces las acciones en el cuerpo de la estructura se ejecutan nunca. La evaluación de la condición sólo se lleva cabo al inicio de cada iteración. Si la condición se vuelve FALSO en algún punto durante la ejecución de un bloque, el programa lo nota hasta que se termine de ejecutar el bloque y la condición sea evaluada antes de comenzar la próxima iteración. Por ejemplo, sería interesante escribir un programa para llenar agujeros como el anterior, pero que sirva de manera general para otras situaciones donde puede haber cualquier cantidad de agujeros en la calle, como estas:  En vez de usar un en el cual hay que especificar la cantidad de veces que el proceso debe repetirse, podemos usar un para que Karel siga rellenando agujeros mientras que haya una pared enfrente suyo, lo cual indicaría que llegó al final y debe detenerse. Hay que tener mucho cuidado la hora de escribir este tipo de estructura, para asegurarse de producir un loop infinito, es decir, un proceso iterativo que nunca finaliza. Esto ocurriría, por ejemplo, si estando en el mundo anterior, le pedimos Karel que gire mientras que haya cosas donde está parada: Algunos ejemplos presentados en este tutorial fueron adaptados de Karel robot learns Java (Eric Roberts, 2005).","code":"while (<condición>) {     ...Acción/es a repetir... } # ------------------- Programa principal ------------------- generar_mundo(\"mundo003\") while (frente_abierto()) {   avanzar()   llenar_agujero()   avanzar() } ejecutar_acciones() # No correr esto! (o sí, para ver cómo no anda!) generar_mundo(\"mundo003\") while (no_hay_cosos()) {     girar_izquierda() } ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"fixing-the-street-again","dir":"Articles","previous_headings":"","what":"Fixing the street again","title":"5 - Examples","text":"previous section, proposed following program solve problem filling holes street: program works worlds streets length. However, work holes evenly spaced initially assumed. better general program works conditions: world can streets length. holes can located position along street, without restrictions number spacing. holes may already filled, Karel put thing . example type world :  solve problem, instead starting iteration move, first check hole Karel standing. , Karel fill already filled, move. Therefore, iterating block modified follows: However, program flaw works situation...  ...work one:  Karel stops without filling last hole. fact, Karel doesn’t even go check needs filled . problem soon Karel fills hole avenue 6, executes move action ends facing wall, causing loop stop evaluating last position. fairly common logical error working iterative structures, solution simple. add additional check loop finished:","code":"> # ------------ Definition of auxiliary functions ----------- >  > # Function: fill_hole > fill_hole <- function() { +   turn_right() +   move() +   if (no_beepers_present()) { +     put_beeper() +   } +   turn_around() +   move() +   turn_right() + } >  > # ------------------- Main program ------------------- >  > generate_world(\"mundo003\") > while (front_is_clear()) { +   move() +   fill_hole() +   move() + } > run_actions() > generate_world(\"mundo006\") > # ------------------- Main program ------------------- >  > generate_world(\"mundo106\") > while (front_is_clear()) { +   if (right_is_clear()) { +       fill_hole() +   } +   move() + } > run_actions() > # ------------------- Main program ------------------- >  > generate_world(\"mundo007\") > while (front_is_clear()) { +   if (right_is_clear()) { +       fill_hole() +   } +   move() + } > run_actions() > # ------------------- Main program ------------------- >  > generate_world(\"mundo007\") > while (front_is_clear()) { +   if (right_is_clear()) { +       fill_hole() +   } +   move() + } > if (right_is_clear()) { +   fill_hole() + } > run_actions()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"create-other-functions-that-make-karel-even-more-powerful","dir":"Articles","previous_headings":"","what":"Create other functions that make Karel even more powerful","title":"5 - Examples","text":"Karel already knows turn, move forward, put, gather beepers. However, can imagine order perform world, certainly activities must frequently repeat. example, moving straight ahead encounters wall, gathering beepers can find along street avenue, emptying backpack putting beepers place none left. Let’s create functions take care tasks Karel can implement time. Move forward encountering wall Collect line beepers Put beepers backpack one place","code":"> # Function: move_forward_until_wall() > # Description: allows Karel to move forward until it encounters a wall > # Initial condition: none > # Final condition: Karel is facing a wall > move_forward_until_wall <- function() { +   while (front_is_clear()) { +     move() +   } + } > # Function: collect_line() > # Description: allows Karel to collect a consecutive line of beepers. The line > # ends at the first cell that does not have beepers. > # Initial condition: none > # Final condition: Karel is at the end of the line, facing the same direction as > # at the beginning > collect_line <- function() { +   while (beepers_present()) { +     pick_beeper() +     if (front_is_clear()) { +       move() +     } +   } + } > > # Function: put_all() > # Description: Karel puts all the beepers in its backpack in its current > # position > # Initial condition: none > # Final condition: none > put_all <- function() { +   while (karel_has_beepers()) { +     put_beeper() +   } + }"},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"collect-columns-of-beepers","dir":"Articles","previous_headings":"","what":"Collect columns of beepers","title":"5 - Examples","text":"example, walls Karel’s world, columns beepers varying heights along avenues, avenues empty. Karel’s job collect columns, leave bottom-right position shown diagram, return initial position:  already said, good advice tackling problem try break smaller parts. Following idea, can imagine main program can composed three parts: collect beepers store backpack, deposit corner, return initial position. Something like : , easy understand needs done. also uses function already defined , put_all(). thing missing, insignificant, write two sub-algorithms, turn can broken smaller problems. First, need collect columns beepers, without knowing many may . suggests use loop. collect column column encounter wall: Note repeated recolectar_una_columna() reason explained previous example. Additionally, telling collect column without checking one... happens isn’t ? Answer question read complete program , assure ’s fine way. course, need create new function recolectar_una_columna() take care Karel: Turn face north. Collect things stopping (problem sound familiar?). Turn around start descent. Go wall representing floor (problem sound familiar?). Turn ready move next column. , function something like : Two functions appeared defined previous exercise, anticipated quite common activities useful already programmed. complete program shown . Remember R need first execute functions invented main program uses .","code":"> generate_world(\"mundo008\") > collect_all() > put_all() > return_to_start() > run_actions() > collect_all <- function() { +   while (front_is_clear()) { +     collect_one_column() +     move() +   } +   collect_one_column() + } > collect_one_column <- function() { +   turn_left() +   collect_line() +   turn_around() +   move_forward_until_wall() +   turn_left() + } > # ------------ Definición de otras funciones auxiliares----------- >  > # Function: collect_all() > # Description: allows collecting all the things in each column by moving along the first avenue. > # Initial condition: Karel is facing east at position (1, 1). > # Final condition: Karel is facing east at the position of the rightmost cell in the first row. > collect_all <- function() { +   while (front_is_clear()) { +     collect_one_column() +     move() +   } +   collect_one_column() + } >  > # Function: collect_one_column() > # Description: allows collecting all the things in a single column > # Initial condition: Karel must be at the base of the column facing east > # Final condition: Karel is in the same position and direction as at the beginning > collect_one_column <- function() { +   turn_left() +   collect_line() +   turn_around() +   move_forward_until_wall() +   turn_left() + } >  > # Function: return_to_start() > # Description: allows Karel to return to position (1, 1) > # Initial condition: Karel is facing east somewhere on the first row > # Final condition: Karel is at position (1, 1) facing east > return_to_start <- function() { +   turn_around() +   move_forward_until_wall() +   turn_around() + } >  > # ------------------- Main program ------------------- > generate_world(\"mundo008\") > collect_all() > put_all() > return_to_start() > run_actions()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"the-maze","dir":"Articles","previous_headings":"","what":"The Maze","title":"5 - Examples","text":"Now let’s imagine Karel maze like one , thing represents exit:  create program Karel can reach , however, general work maze. strategy solve maze: enter, touch wall right hand walk without ever letting go , eventually reach exit. known right-hand rule translates always turning right, every path choice arises (course, also work always turned left). brief program presented implements right-hand algorithm. Many times, programs solve interesting problems neither long convoluted. Look carefully convinced understand logic algorithm:","code":"> # ------------------- Main program ------------------- >  > generate_world(\"mundo009\") > while (no_beepers_present()) { +   turn_right() +   while (frente_cerrado()) { +     turn_left() +   } +   move() + } > run_actions()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"more-problems","dir":"Articles","previous_headings":"","what":"More Problems","title":"5 - Examples","text":"Next, propose exercises continue reviewing learned Karel.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-1-collecting-the-newspaper","dir":"Articles","previous_headings":"More Problems","what":"Problem 1: Collecting the newspaper","title":"5 - Examples","text":"warm , let’s start simple problem. Imagine Karel home, square region center following diagram:  Karel must leave house pick newspaper (represented, course, thing) return initial position, place newspaper start reading. Let’s assume Karel’s house (size, location door newspaper) change, meaning don’t generalize problem possible configurations. Write program R following ways: . First, solve problem using Karel’s four basic actions (advance, turn left, put, collect things). b. Second, solve problem using principle algorithmic decomposition. , create sub-algorithm takes care Karel leaving house another Karel entering returning initial position. Use main algorithm. Additionally, can use Karel’s superpowers (turn right turn around), whose functions R available run cargar_super_karel() beforehand. Use world: \"mundo011\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-2-going-around-the-house","dir":"Articles","previous_headings":"More Problems","what":"Problem 2: Going around the house","title":"5 - Examples","text":"Now let’s assume Karel needs exercise bit, , leave house make exactly three turns around clockwise direction. Write algorithm program , considering structure world provided previous problem (\"mundo011\"). Use sub-algorithms created problem 1.b, well others consider necessary create. Karel end position direction started.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-3-creating-a-line-of-beepers","dir":"Articles","previous_headings":"More Problems","what":"Problem 3: Creating a line of beepers","title":"5 - Examples","text":"Write function Karel place line things starting current position advancing encounters wall front. example, result executing function empty world like :  function work worlds size. Use worlds: \"mundo012\", \"mundo013\", \"mundo014\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-4-jumping-over-sticks","dir":"Articles","previous_headings":"More Problems","what":"Problem 4: Jumping over sticks","title":"5 - Examples","text":"Write program Karel jump sticks shown following diagram:  considerations: Karel “jumps” sticks going around , one time. Karel starts position (1, 1) must end position (9, 1). solution work worlds may different number sticks different lengths, always width 9 avenues. Use worlds: \"mundo015\" \"mundo016\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-5-cleaning-the-world","dir":"Articles","previous_headings":"More Problems","what":"Problem 5: Cleaning the World","title":"5 - Examples","text":"problem, need help Karel clean world since things scattered everywhere. assumed : Karel starts position (1, 1). Initially, position world may empty one thing, end, things left world. Karel can position direction end. example, running program following world, expected result:  Use worlds: \"mundo017\" \"mundo018\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-6-placing-beepers-in-the-vertices-of-the-diamond","dir":"Articles","previous_headings":"More Problems","what":"Problem 6: Placing beepers in the vertices of the diamond","title":"5 - Examples","text":"Write program Karel place things vertices diamond enclosed , shown :  program work worlds size diamond may vary, can assume Karel always starts positioned western vertex, facing east. Use worlds mundo019 mundo020.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-7-doubling-the-number-of-beepers","dir":"Articles","previous_headings":"More Problems","what":"Problem 7: Doubling the number of beepers","title":"5 - Examples","text":"Write program Karel duplicate number things specific position. example:  Assume : world always looks like diagram (size walls). things duplicated always position (3, 3), twice many things position program finishes. initial number things position (3, 3) can , least one thing always present. Karel infinite number things bag. main program : words, write function called duplicar_cosos() responsible performing task, turn can decomposed sub-algorithms. Use world mundo021.","code":"> # Main program > generate_world(\"mundo021\") > move() > duplicate_beepers() > move() > run_actions()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_en.html","id":"problem-8-repairing-columns","dir":"Articles","previous_headings":"More Problems","what":"Problem 8: Repairing columns","title":"5 - Examples","text":"Karel hired restore columns ancient wall, , must place missing stones, represented things, . , must achieve :  Write program works scheme also general enough work walls (worlds) meet following characteristics: Karel initially finds intersection Avenue 1 Street 1, facing east, infinite number things bag. columns always distance 4 positions, Avenue 1, 5, 9, etc. end sequence columns determined wall (world’s edge) immediately last column. example diagram, ends Avenue 13, end 5, 9, 13, 17, etc. upper edge column determined horizontal wall, Karel assume height columns always 5 example, columns height. parts columns thing, representing stones need repair. Karel place second thing . final position direction Karel matter. Use worlds mundo022, mundo023, mundo024.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"otra-vez-a-reparar-la-calle","dir":"Articles","previous_headings":"","what":"Otra vez a reparar la calle","title":"5 - Varios problemas de ejemplo","text":"En la sección anterior propusimos el siguiente programa para resolver el problema de llenar los agujeros de la calle: Este programa sirve para mundos con calles de cualquier largo, sin embargo serviría si los agujeros estuviesen equiespaciados como asumimos inicialmente. Sería mejor tener un programa más general que funcione bajo estas condiciones: El mundo puede tener calles de cualquier largo. Los agujeros pueden estar en cualquier posición lo largo de la calle, sin restricciones en cuanto la cantidad o su espaciado. Algunos agujeros podrían estar ya reparados, de modo que Karel debe poner un coso en ellos. Un ejemplo de este tipo de mundo es este:  Para solucionar este problema, en vez de comenzar cada iteración con un avance, deberíamos primero chequear si donde Karel está parada hay un agujero, si es así llenarlo en el caso de que estuviese reparado y luego avanzar. Por lo tanto se debe modificar el bloque que se itera: Sin embargo, este programa tiene una falla, porque si bien anda en esta situación…  …funciona en esta:  Karel se detiene sin llenar el último agujero. De hecho, Karel ni siquiera desciende para ver si hay que llenarlo o . El problema está en que apenas Karel rellena el agujero de la avenida 6, ejecuta la acción de avanzar, quedando enfrente de una pared, lo cual hace que el loop se detenga antes de evaluar esa última posición. Este es un error lógico bastante frecuente cuando se trabaja con estructuras iterativas, pero su solución es sencilla. Lo único que tenemos que hacer es agregar un chequeo adicional después de haber finalizado el :","code":"> # ------------ Definición de funciones auxiliares----------- >  > # Función: llenar_agujero > llenar_agujero <- function() { +   girar_derecha() +   avanzar() +   if (no_hay_cosos()) { +     poner_coso() +   } +   darse_vuelta() +   avanzar() +   girar_derecha() + } >  > # ------------------- Programa principal ------------------- >  > generar_mundo(\"mundo003\") > while (frente_abierto()) { +   avanzar() +   llenar_agujero() +   avanzar() + } > ejecutar_acciones() > generar_mundo(\"mundo006\") > # ------------------- Programa principal ------------------- >  > generar_mundo(\"mundo106\") > while (frente_abierto()) { +   if (derecha_abierto()) { +       llenar_agujero() +   } +   avanzar() + } > ejecutar_acciones() > # ------------------- Programa principal ------------------- >  > generar_mundo(\"mundo007\") > while (frente_abierto()) { +   if (derecha_abierto()) { +       llenar_agujero() +   } +   avanzar() + } > ejecutar_acciones() > # ------------------- Programa principal ------------------- >  > generar_mundo(\"mundo007\") > while (frente_abierto()) { +   if (derecha_abierto()) { +       llenar_agujero() +   } +   avanzar() + } > if (derecha_abierto()) { +   llenar_agujero() + } > ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"crear-otras-funciones-que-hagan-de-karel-aún-más-poderosa","dir":"Articles","previous_headings":"","what":"Crear otras funciones que hagan de Karel aún más poderosa","title":"5 - Varios problemas de ejemplo","text":"Karel ya sabe girar, avanzar, poner y juntar cosos. Sin embargo, podemos imaginar que para desempeñarse en su mundo, seguramente hay algunas actividades que debe repetir menudo. Por ejemplo, avanzar derechito hasta que se encuentre con una pared, juntar todos los cosos que se pueda encontrar lo largo de una calle o avenida o vaciar su mochila poniendo cosos en un lugar hasta que ya le quede ninguno. Vamos crear funciones que se encarguen de estas tareas, de modo que Karel pueda implementarlas en cualquier momento. Avanzar hasta encontrarse con una pared Recolectar una línea de cosos Poner todos los cosos que tiene en la mochila en un lugar","code":"> # Función: avanzar_hasta_pared() > # Descripción: permite que Karel avance hasta que encuentre una pared > # Condición inicial: ninguna > # Condición final: Karel queda enfrentada a una pared > avanzar_hasta_pared <- function() { +   while (frente_abierto()) { +     avanzar() +   } + } > # Función: recolectar_linea() > # Descripción: permite recolectar una línea consecutiva de cosos. La línea > # termina en la primera celda que no tiene cosos. > # Condición inicial: ninguna > # Condición final: Karel está en el final de la línea con la misma dirección que > # al inicio > recolectar_linea <- function() { +   while (hay_cosos()) { +     juntar_coso() +     if (frente_abierto()) { +       avanzar() +     } +   } + } > # Función: colocar_todo() > # Descripción: Karel coloca todos los cosos que tiene en su mochila en su > # posición actual > # Condición inicial: ninguna > # Condición final: ninguna > colocar_todo <- function() { +   while (karel_tiene_cosos()) { +     poner_coso() +   } + }"},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"recoger-columnas-de-cosos","dir":"Articles","previous_headings":"","what":"Recoger columnas de cosos","title":"5 - Varios problemas de ejemplo","text":"En este ejemplo, hay paredes en el mundo de Karel pero en algunas avenidas hay columnas de cosos de cualquier altura, mientras que otras avenidas están vacías. El trabajo de Karel es recolectarlas todas, dejarlas en la posición de abajo la derecha como muestra el diagrama y volver su posición inicial:  Como ya hemos dicho, un buen consejo para encarar cualquier problema es tratar de descomponerlo en partes más pequeñas. Siguiendo esta idea, podemos imaginarnos que el programa principal puede estar compuesto por tres partes: recolectar todos los cosos y guardarlos en su mochila que inicialmente estará vacía, depositarlos en la esquina y volver la posición inicial. Algo como esto: Así como está, es muy sencillo entender qué es lo que hay que hacer. Además, hace uso de una función que ya tenemos definida de antes, colocar_todo(). Lo único que falta, que es poco, es escribir los otros dos subalgoritmos, que su vez pueden descomponerse en otros problemas menores. En primer instancia, hay que recolectar todas las columnas de cosos, sin saber cuántas pueden ser, esto nos hace pensar en que será necesario un . Tenemos que recolectar columna por columna hasta que nos encontremos con la pared: Notar que después del hemos repetido recolectar_una_columna(), por la razón expuesta en el ejemplo anterior. Además, le estamos diciendo que recolecte la columna sin haber chequeado si había una… ¿qué pasa si hay ninguna? Respondé esta pregunta cuando leas el programa completo más abajo, pero te aseguramos que está bien hacerlo así. Claro que entonces necesitamos crear esta nueva función recolectar_una_columna(), que tiene que encargarse de que Karel: Gire para mirar hacia el norte. Recolecte todos los cosos deteniéndose cuando ya haya más (¿te suena este problema?. Se dé vuelta para emprender el descenso. Baje hasta la pared que representa al piso (¿te suena este problema?). Vuelva girar para estar lista para avanzar la siguiente columna. Entonces, la función tiene que ser algo así: Aparecieron por ahí dos funciones que definimos en el ejercicio anterior, que como anticipamos son actividades bastante comunes que nos viene muy bien tenerlas ya programadas. El programa completo se muestra continuación. Recordar que en R necesitamos ejecutar primero las funciones que hemos inventado y luego el programa principal que las utiliza.","code":"> generar_mundo(\"mundo008\") > recolectar_todo() > colocar_todo() > volver_inicio() > ejecutar_acciones() > recolectar_todo <- function() { +   while (frente_abierto()) { +     recolectar_una_columna() +     avanzar() +   } +   recolectar_una_columna() + } > recolectar_una_columna <- function() { +   girar_izquierda() +   recolectar_linea() +   darse_vuelta() +   avanzar_hasta_pared() +   girar_izquierda() + } > # ------------ Definición de otras funciones auxiliares----------- >  > # Función: recolectar_todo() > # Descripción: permite recolectar todos los cosos de cada columna moviéndose a > # lo largo de la primera calle. > # Condición inicial: Karel está mirando al este en la posición (1, 1) > # Condición final: Karel está mirando al este en la posición del extremo derecho > # de la primera fila > recolectar_todo <- function() { +   while (frente_abierto()) { +     recolectar_una_columna() +     avanzar() +   } +   recolectar_una_columna() + } >  > # Función: recolectar_una_columna() > # Descripción: permite recolectar todos los cosos en una única columna > # Condición inicial: Karel debe estar en la base de la columna mirando al este > # Condición final: Karel está en la misma posición y dirección que al inicio > recolectar_una_columna <- function() { +   girar_izquierda() +   recolectar_linea() +   darse_vuelta() +   avanzar_hasta_pared() +   girar_izquierda() + } >  > # Función: volver_inicio() > # Descripción: permite que Karel regrese a la posición (1, 1) > # Condición inicial: Karel mira al este en algún lugar de la primera fila > # Condición final: Karel está en la posición (1, 1) mirando al este > volver_inicio <- function() { +   darse_vuelta() +   avanzar_hasta_pared() +   darse_vuelta() + } >  > # ------------------- Programa principal ------------------- > generar_mundo(\"mundo008\") > recolectar_todo() > colocar_todo() > volver_inicio() > ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"el-laberinto","dir":"Articles","previous_headings":"","what":"El laberinto","title":"5 - Varios problemas de ejemplo","text":"Ahora nos vamos imaginar que Karel está en un laberinto como el siguiente, donde el coso indica la salida:  Tenemos que crear un programa para que Karel pueda llegar hasta ahí, sin embargo tiene que ser general para que sirva para este y cualquier otro laberinto. Hay una estrategia para resolver cualquier laberinto: si cuando entrás tocás con tu mano la pared tu derecha y caminás sin dejar de tocarla nunca, eventualmente llegarás la salida. Esto se conoce como la regla de la mano derecha y se traduce en doblar siempre la derecha, en toda selección de caminos que se te presente (por supuesto, también serviría si se hiciera siempre con la izquierda). El breve programa que se presenta continuación implementa el algoritmo de la mano derecha. Muchas veces, los programas que resuelven problemas muy interesantes son ni largos ni rebuscados. Miralo con atención hasta que estés convencido de entender la lógica de este algoritmo:","code":"> # ------------------- Programa principal ------------------- >  > generar_mundo(\"mundo009\") > while (no_hay_cosos()) { +   girar_derecha() +   while (frente_cerrado()) { +     girar_izquierda() +   } +   avanzar() + } > ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"más-problemas","dir":"Articles","previous_headings":"","what":"Más problemas","title":"5 - Varios problemas de ejemplo","text":"continuación se dejan propuestos algunos ejercicios para seguir repasando lo aprendido junto Karel.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-1-juntar-el-periódico","dir":"Articles","previous_headings":"Más problemas","what":"Problema 1: juntar el periódico","title":"5 - Varios problemas de ejemplo","text":"Para calentar motores, comenzaremos con un problema simple. Imaginemos que Karel está en su casa, la cual es la región cuadrada en el centro del siguiente diagrama:  Karel debe salir de su casa para recoger el periódico (representado, obviamente, por un coso) y volver su posición inicial, donde colocará el periódico para ponerse leer. Vamos asumir que la casa de Karel (su tamaño, la ubicación de la puerta y del periódico) sufren cambios, es decir, hay que generalizar este problema para otras configuraciones posibles del esquema. Escribir el programa en R, de las siguientes formas: En primer lugar, se debe resolver este problema usando solamente las cuatro acciones básicas de Karel (avanzar, girar la izquierda, poner y juntar cosos). En segundo lugar, resolver el problema empleando el principio de la descomposición algorítmica. Para esto, un subalgoritmo que se encargue de que Karel salga de su casa y otro para que Karel ingrese y regrese la posición inicial. Usarlos en el algoritmo principal. Además, se puede hacer uso de los superpoderes de Karel (girar la derecha y darse vuelta), cuyas funciones en R están disponibles si previamente corremos cargar_super_karel(). Utilizar el mundo: \"mundo011\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-2-dar-vueltas-a-la-casa","dir":"Articles","previous_headings":"Más problemas","what":"Problema 2: dar vueltas a la casa","title":"5 - Varios problemas de ejemplo","text":"Ahora vamos suponer que Karel tiene ejercitarse un poco y para eso va salir de su casa y dar exactamente tres vueltas alrededor de la misma, en sentido de las agujas del reloj. Escribir el algoritmo y el programa que permiten hacer esto, teniendo en cuenta la estructura del mundo provisto en el problema anterior (\"mundo011\"). Emplear los subalgoritmos creados en el problema 1.b, así como cualquier otro que consideres necesario crear. Karel debe finalizar con la misma posición y dirección que tenía al comienzo.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-3-crear-línea-de-cosos","dir":"Articles","previous_headings":"Más problemas","what":"Problema 3: crear línea de cosos","title":"5 - Varios problemas de ejemplo","text":"Escribir una función para que Karel coloque una línea de cosos comenzando en su posición actual y avanzando hasta que encuentre una pared enfrente. Por ejemplo: el resultado de ejecutar esta función en un mundo vacío sería este:  La función debe servir para mundos de cualquier tamaño. Utilizar los mundos: \"mundo012\", \"mundo013\" y \"mundo014\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-4-saltar-los-palotes","dir":"Articles","previous_headings":"Más problemas","what":"Problema 4: saltar los palotes","title":"5 - Varios problemas de ejemplo","text":"Escribir un programa para que Karel pueda saltar palotes como en el siguiente esquema:  Algunas consideraciones: Karel “salta” los palotes bordeándolos, de uno por vez. Karel comienza en la posición (1, 1) y debe terminar en la (9, 1). La solución debe funcionar en mundos que pueden tener distinta cantidad de palotes y de distintos largos, pero siempre con 9 avenidas de ancho. Usar los mundos: \"mundo015\" y \"mundo016\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-5-limpiar-el-mundo","dir":"Articles","previous_headings":"Más problemas","what":"Problema 5: limpiar el mundo","title":"5 - Varios problemas de ejemplo","text":"En este problema tenemos que ayudar Karel limpiar su mundo, dado que hay cosos dando vuelta por todos lados. Se debe asumir que: Karel comienza en la posición (1, 1). Inicialmente, cada posición en el mundo puede estar vacía o tener cuanto mucho un coso y al finalizar, debe quedar ningún coso en el mundo. Karel puede tener cualquier posición y dirección al finalizar. Por ejemplo, al correr tu programa en el siguiente mundo, este sería el resultado esperado:  Utilizar los mundos: \"mundo017\" y \"mundo018\".","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-6-poner-cosos-en-los-vértices-del-rombo","dir":"Articles","previous_headings":"Más problemas","what":"Problema 6: poner cosos en los vértices del rombo","title":"5 - Varios problemas de ejemplo","text":"Escribir un programa para que Karel pueda colocar cosos en los vértices del rombo en en el cual está encerrada, como se muestra continuación:  El programa debe funcionar en mundos donde el tamaño del rombo puede ser distinto, pero se puede asumir que Karel siempre inicia posicionada en el vértice que da al oeste, mirando hacia el este. Utilizar los mundos mundo019 y mundo020.","code":""},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-7-duplicar-el-número-de-cosos","dir":"Articles","previous_headings":"Más problemas","what":"Problema 7: duplicar el número de cosos","title":"5 - Varios problemas de ejemplo","text":"Escribir un programa para que Karel pueda duplicar el número de cosos que se encuentran en una posición determinada. Por ejemplo:  Asumir que: el mundo siempre luce como en el diagrama anterior (mismo tamaño y sin paredes). los cosos que deben ser duplicados están siempre en la posición (3, 3) y allí mismo deberá estar el doble de cosos al terminar. la cantidad inicial de cosos en la posición (3, 3) puede ser cualquiera, habiendo siempre al menos uno. Karel tiene infinitos cosos en su mochila. El programa principal debe ser: Es decir, deberán escribir una función, llamada duplicar_cosos() que se encargue de realizar esta tarea, el cual su vez puede estar descompuesto en otros subalgoritmos. Utilizar el mundo mundo021.","code":"> # Programa principal > generar_mundo(\"mundo021\") > avanzar() > duplicar_cosos() > avanzar() > ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/articles/e_examples_es.html","id":"problema-8-reparar-columnas","dir":"Articles","previous_headings":"Más problemas","what":"Problema 8: reparar columnas","title":"5 - Varios problemas de ejemplo","text":"Karel fue contratada para restaurar las columnas de un antiguo paredón y para esto debe colocarles las piedras que les faltan, representadas obviamente por cosos. Es decir, tiene que lograr esto:  Escribir un programa que funcione en el esquema anterior, pero que además sea lo suficientemente general como para que funcione en otros paredones (mundos) que cumplan con las características mencionadas continuación: Karel inicialmente se encuentra en la intersección de Avenida 1 y Calle 1, mirando al este, con una cantidad infinita de cosos en su mochila. Las columnas están siempre una distancia de 4 posiciones, en la Avenida 1, 5, 9, etc. El final de la secuencia de columnas está determinado por la pared (el borde del mundo) inmediatamente después de la última columna. En el diagrama de ejemplo, termina luego de la Avenida 13, pero podría terminar luego de la 5, 9, 13, 17, etc. El borde superior de la columna está determinado por una pared horizontal, pero Karel debe asumir que la altura de las columnas sea siempre de 5 como en el ejemplo, ni tampoco que todas las columnas tengan la misma altura. Algunas partes de las columnas tienen un coso, representando piedras que necesitan reparación, Karel debe colocar un segundo coso sobre ellas. La posición y dirección final de Karel importan. Utilizar los mundos mundo022, mundo023 y mundo024.","code":""},{"path":"https://ropensci.github.io/karel/authors.html","id":null,"dir":"","previous_headings":"","what":"Autores","title":"Autores y Citas","text":"Marcos Prunello. Autor-, mantenedor-, titular de los derechos de autor.","code":""},{"path":"https://ropensci.github.io/karel/authors.html","id":"citation","dir":"","previous_headings":"","what":"Cita","title":"Autores y Citas","text":"Prunello M (2024). karel: Learning programming Karel robot. R package version 0.1.1.9000, <https://mpru.github.io/karel/>.","code":"@Misc{karelpackage,   title = {karel: Learning programming with Karel the robot},   author = {Marcos Prunello},   year = {2024},   url = {https://mpru.github.io/karel/}, }"},{"path":[]},{"path":"https://ropensci.github.io/karel/index.html","id":"quién-es-karel--who-is-karel","dir":"","previous_headings":"","what":"¿Quién es Karel? / Who is Karel?","title":"Learning programming with Karel the robot","text":"Desarrollado por el Dr. R. E. Pattis en la Universidad de Stanford en 1981, Karel es una herramienta que persigue la misión de enseñar conceptos fundamentales y generales de programación, como descomposición algorítmica, declaraciones condicionales, bucles y más. Aunque Karel ha sido implementado en varios lenguajes lo largo de los años, este es el primer paquete que trae Karel al entorno de R. Esta herramienta es útil para ser utilizada con estudiantes que tienen experiencia previa en R ni en otro lenguaje, pero que deben adquirir nociones elementales de programación porque necesitan comenzar usar R para sus estudios. El paquete pretende ayudar incorporar estos conocimientos de forma lúdica, permitiendo que los usuarios jueguen y completen desafíos con Karel. Por ejemplo, este paquete es utilizado en un curso informal de pre-ingreso la carrera de Licenciatura en Estadística en la Universidad Nacional de Rosario (Argentina) con futuros estudiantes que en su mayoría son adolescentes y tienen experiencia en programación. El paquete Karel ofrece través de sus viñetas lecciones para transmitir estos conocimientos generales que, si bien incluyen herramientas de programación para análisis de datos o técnicas de codificación avanzadas, se enfocan en las bases de la programación, enseñadas en el entorno R. Developed Dr. R. E. Pattis Stanford University 1981, Karel tool aimed teaching fundamental general programming concepts, algorithmic decomposition, conditional statements, loops, . Although Karel implemented various languages years, first package bring Karel R environment. tool useful used students prior experience R language need acquire basic programming notions need start using R studies. package aims help incorporate knowledge playful way, allowing users play complete challenges Karel. example, package used informal pre-entry course Bachelor’s degree Statistics National University Rosario (Argentina) future students mostly teenagers programming experience. Karel package offers lessons vignettes convey general knowledge, , including programming tools data analysis advanced coding techniques, focus foundations programming, taught R environment.","code":""},{"path":"https://ropensci.github.io/karel/index.html","id":"instalación--installation","dir":"","previous_headings":"","what":"Instalación / Installation","title":"Learning programming with Karel the robot","text":"Podés instalar karel desde CRAN / can install karel CRAN: También podés instalar la versión en desarrollo desde GitHub / can also install development version GitHub:","code":"install.packages(\"karel\") # install.packages(\"devtools\") devtools::install_github(\"ropensci/karel\")"},{"path":"https://ropensci.github.io/karel/index.html","id":"ejemplos--examples","dir":"","previous_headings":"","what":"Ejemplos / Examples","title":"Learning programming with Karel the robot","text":"Podés programar Karel para que realice tareas como las siguientes / can program Karel perform tasks :   Visitá los artículos para ver cómo lograrlo y solucionar muchos casos más / Visit articles learn solve problems.","code":""},{"path":"https://ropensci.github.io/karel/index.html","id":"cómo-citar-este-paquete--how-to-cite-this-package","dir":"","previous_headings":"","what":"Cómo citar este paquete / How to cite this package","title":"Learning programming with Karel the robot","text":"","code":"Prunello M (2023). karel: Learning programming with Karel the robot.  R package version 0.1.1.9000, <https://ropensci.github.io/karel/>."},{"path":"https://ropensci.github.io/karel/index.html","id":"código-de-conducta--code-of-conduct","dir":"","previous_headings":"","what":"Código de conducta / Code of conduct","title":"Learning programming with Karel the robot","text":"Por favor notar que este paquete se ha publicado con un Código de Conducta. Please note package released Contributor Code Conduct. Please note package released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://ropensci.github.io/karel/reference/acciones.html","id":null,"dir":"Reference","previous_headings":"","what":"Acciones que Karel puede realizar — acciones","title":"Acciones que Karel puede realizar — acciones","text":"avanzar(), girar_izquierda(), juntar_coso() y poner_coso() son las cuatro actividades básicas que Karel sabe realizar. Si se habilitan los superpoderes de Karel con cargar_super_karel(), entonces también puede girar_derecha() y darse_vuelta().","code":""},{"path":"https://ropensci.github.io/karel/reference/acciones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Acciones que Karel puede realizar — acciones","text":"","code":"avanzar()  girar_izquierda()  poner_coso()  juntar_coso()  girar_derecha()  darse_vuelta()"},{"path":"https://ropensci.github.io/karel/reference/acciones.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Acciones que Karel puede realizar — acciones","text":"Estas funciones devuelven nada, pero realizan cambios en el mundo   de Karel que se ven cuando se ejecutan todas las acciones con   ejecutar_acciones().","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/acciones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Acciones que Karel puede realizar — acciones","text":"","code":"generar_mundo(\"mundo001\")  avanzar() juntar_coso() girar_izquierda() poner_coso() if (interactive()) ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/reference/actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Available actions for Karel — actions","title":"Available actions for Karel — actions","text":"move(), turn_left(), pick_beeper() y put_beeper() four basic activities Karel can perform. turn Karel's superpowers load_super_karel(), can also turn_right() y turn_around().","code":""},{"path":"https://ropensci.github.io/karel/reference/actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Available actions for Karel — actions","text":"","code":"move()  turn_left()  put_beeper()  pick_beeper()  turn_right()  turn_around()"},{"path":"https://ropensci.github.io/karel/reference/actions.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Available actions for Karel — actions","text":"functions return anything, make changes Karel's   world visible actions run   run_actions().","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/actions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Available actions for Karel — actions","text":"","code":"generate_world(\"mundo001\")  move() pick_beeper() turn_left() put_beeper() if (interactive()) run_actions()"},{"path":"https://ropensci.github.io/karel/reference/cargar_super_karel.html","id":null,"dir":"Reference","previous_headings":"","what":"Habilitar los superpoderes de Karel — cargar_super_karel","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"Luego de correr cargar_super_karel(), Karel también puede girar la derecha y darse vuelta, través de las acciones girar_derecha() y darse_vuelta(). Si se cargan los superpoderes, estas dos funciones están disponibles.","code":""},{"path":"https://ropensci.github.io/karel/reference/cargar_super_karel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"","code":"cargar_super_karel()"},{"path":"https://ropensci.github.io/karel/reference/cargar_super_karel.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"devuelve ningún valor, pero adjuntan al Global Environment las   funciones girar_derecha() y darse_vuelta().","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/cargar_super_karel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Habilitar los superpoderes de Karel — cargar_super_karel","text":"","code":"generar_mundo(\"mundo001\")  cargar_super_karel() darse_vuelta() girar_derecha() if (interactive()) ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/reference/check_user_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Check user's own world — check_user_world","title":"Check user's own world — check_user_world","text":"function analyzes world provided user satisfies requirements.","code":""},{"path":"https://ropensci.github.io/karel/reference/check_user_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Check user's own world — check_user_world","text":"","code":"check_user_world(world, lang)"},{"path":"https://ropensci.github.io/karel/reference/check_user_world.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Check user's own world — check_user_world","text":"world world provided user. list. See details generar_mundo.","code":""},{"path":"https://ropensci.github.io/karel/reference/check_user_world.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Check user's own world — check_user_world","text":"misespecification found, function produces stop   provides descriptive error message.","code":""},{"path":"https://ropensci.github.io/karel/reference/check_user_world.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Check user's own world — check_user_world","text":"function called .generate_world.","code":""},{"path":"https://ropensci.github.io/karel/reference/check_walls.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the walls user's provided world — check_walls","title":"Check the walls user's provided world — check_walls","text":"helper function check ver_walls hor_walls. called check_user_world twice.","code":""},{"path":"https://ropensci.github.io/karel/reference/check_walls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Check the walls user's provided world — check_walls","text":"","code":"check_walls(dataset, name, nx, ny, lang)"},{"path":"https://ropensci.github.io/karel/reference/check_walls.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Check the walls user's provided world — check_walls","text":"dataset Either hor_walls ver_walls name Character string: \"hor_walls\" \"ver_walls\" nx, ny Size world lang language code (\"en\" \"es\") printing messages","code":""},{"path":"https://ropensci.github.io/karel/reference/check_walls.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Check the walls user's provided world — check_walls","text":"misespecification found, function produces stop   provides descriptive error message.","code":""},{"path":"https://ropensci.github.io/karel/reference/condiciones.html","id":null,"dir":"Reference","previous_headings":"","what":"Condiciones que Karel puede verificar — condiciones","title":"Condiciones que Karel puede verificar — condiciones","text":"Este conjunto de funciones devuelven un valor lógico TRUE o FALSE según la evaluación que Karel puede hacer de su mundo.","code":""},{"path":"https://ropensci.github.io/karel/reference/condiciones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Condiciones que Karel puede verificar — condiciones","text":"","code":"frente_abierto()  frente_cerrado()  izquierda_abierto()  izquierda_cerrado()  derecha_abierto()  derecha_cerrado()  hay_cosos()  no_hay_cosos()  karel_tiene_cosos()  karel_no_tiene_cosos()  mira_al_este()  mira_al_oeste()  mira_al_norte()  mira_al_sur()"},{"path":"https://ropensci.github.io/karel/reference/condiciones.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Condiciones que Karel puede verificar — condiciones","text":"Valor lógico TRUE o FALSE.","code":""},{"path":"https://ropensci.github.io/karel/reference/condiciones.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Condiciones que Karel puede verificar — condiciones","text":"Las funciones frente_abierto(), frente_cerrado(),   izquierda_abierto(), izquierda_cerrado(),   derecha_abierto() y derecha_cerrado() analizan si hay paredes   al frente, la izquierda o la derecha de Karel. Las funciones   hay_cosos() y no_hay_cosos() analizan si hay cosos en   la posición actual de Karel. Las funciones karel_tiene_cosos() y   karel_no_tiene_cosos() analizan si Karel tiene cosos en su   mochila (visibles en la representación gráfica). Las funciones   mira_al_este(), mira_al_oeste(), mira_al_norte() y   mira_al_sur() analizan la dirección hacia la cual Karel está   mirando.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/condiciones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Condiciones que Karel puede verificar — condiciones","text":"","code":"generar_mundo(\"mundo001\")  frente_abierto() #> [1] TRUE frente_cerrado() #> [1] FALSE izquierda_abierto() #> [1] TRUE izquierda_cerrado() #> [1] FALSE derecha_abierto() #> [1] FALSE derecha_cerrado() #> [1] TRUE hay_cosos() #> [1] FALSE no_hay_cosos() #> [1] TRUE karel_tiene_cosos() #> [1] TRUE karel_no_tiene_cosos() #> [1] FALSE mira_al_este() #> [1] TRUE mira_al_oeste() #> [1] FALSE mira_al_norte() #> [1] FALSE mira_al_sur() #> [1] FALSE"},{"path":"https://ropensci.github.io/karel/reference/conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditions that Karel can test — conditions","title":"Conditions that Karel can test — conditions","text":"group functions return logical value TRUE FALSE according Karel's evaluation world.","code":""},{"path":"https://ropensci.github.io/karel/reference/conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Conditions that Karel can test — conditions","text":"","code":"front_is_clear()  front_is_blocked()  left_is_clear()  left_is_blocked()  right_is_clear()  right_is_blocked()  beepers_present()  no_beepers_present()  karel_has_beepers()  karel_has_no_beepers()  facing_east()  facing_west()  facing_north()  facing_south()"},{"path":"https://ropensci.github.io/karel/reference/conditions.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Conditions that Karel can test — conditions","text":"Logical value TRUE FALSE.","code":""},{"path":"https://ropensci.github.io/karel/reference/conditions.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Conditions that Karel can test — conditions","text":"functions front_is_clear(), front_is_blocked(),   left_is_clear(), left_is_blocked(), right_is_clear() y   right_is_blocked() test wall front Karel,   left right, respectively. functions beepers_present()   no_beepers_present() test whether   beepers Karel's current position. functions   karel_has_beepers() karel_has_no_beepers() test Karel   beepers bag (visible plot).   functions facing_east(), facing_west(), facing_north()   facing_south() test direction Karel facing right   now.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/conditions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Conditions that Karel can test — conditions","text":"","code":"generate_world(\"mundo001\")  front_is_clear() #> [1] TRUE front_is_blocked() #> [1] FALSE left_is_clear() #> [1] TRUE left_is_blocked() #> [1] FALSE right_is_clear() #> [1] FALSE right_is_blocked() #> [1] TRUE beepers_present() #> [1] FALSE no_beepers_present() #> [1] TRUE karel_has_beepers() #> [1] TRUE karel_has_no_beepers() #> [1] FALSE facing_east() #> [1] TRUE facing_west() #> [1] FALSE facing_north() #> [1] FALSE facing_south() #> [1] FALSE"},{"path":"https://ropensci.github.io/karel/reference/conseguir_amb.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener el ambiente de Karel — conseguir_amb","title":"Obtener el ambiente de Karel — conseguir_amb","text":"Esta función devuelve un ambiente (R environment) llamado pkg_env, que es creado por el paquete. Se puede usar para probar el funcionamiento del paquete. Es una función interna, está pensada para ser usada por estudiantes, pero se puede usar con karel:::conseguir_amb().","code":""},{"path":"https://ropensci.github.io/karel/reference/conseguir_amb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Obtener el ambiente de Karel — conseguir_amb","text":"","code":"conseguir_amb()"},{"path":"https://ropensci.github.io/karel/reference/conseguir_amb.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Obtener el ambiente de Karel — conseguir_amb","text":"Un ambiente de R con objetos que representan al mundo de Karel.","code":""},{"path":"https://ropensci.github.io/karel/reference/conseguir_amb.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Obtener el ambiente de Karel — conseguir_amb","text":"pkg_env es un ambiente de R creado dentro del paquete para   guardar y compartir entre las funciones todos los objetos relacionados con   el mundo de Karel y su estado en cada momento. Dado que estas funciones que   usan los estudiantes deben ser simples y usar argumentos (como, por   ejemplo, avanzar()) estas funciones modifican internamente   pkg_env para implementar cada acción. Los componentes de este ambiente son: nx: tamaño del mundo de Karel, número de celdas en el eje x ny: tamaño del mundo de Karel, número de celdas en el eje x hor_walls: un data.frame con una fila por cada pared     horizontal que hay en el mundo de Karel y 3 columnas: x (coordenada del     inicio de la pared en el eje x), y (coordenada del inicio de la pared en     el eje y), lgth (longitud de la pared, en cantidad de celdas que abarca).     Si toma el valor NULL, hay paredes horizontales en el mundo. ver_walls: un data.frame con una fila por cada pared     vertical que hay en el mundo de Karel y 3 columnas: x (coordenada del     inicio de la pared en el eje x), y (coordenada del inicio de la pared en     el eje y), lgth (longitud de la pared, en cantidad de celdas que abarca).     Si toma el valor NULL, hay paredes verticales en el mundo. open_moves: un arreglo de dimensión nx x ny x 4 de valores     TRUE/FALSE que indica si Karel puede moverse en cada dirección desde una     posición determinada. Para ejemplo, si Karel está en la esquina inferior     izquierda, que es la celda [1, 1], puede ir al sur ni la izquierda,     por lo que tenemos open_moves[1, 1, 3] y open_moves[1, 1, 4] establecido     en FALSO. Dependiendo de las paredes existentes podría moverse al sur o     al norte, por lo que open_moves[1, 1, 1] y open_moves[1, 1, 2] puede ser     VERDADERO o FALSO. Teniendo en cuenta el tamaño del mundo y la paredes,     este arreglo es creado por la función interna     generate_open_moves. karel: un data.frame con una fila para cada momento, en el     que se registra cada estado de Karel lo largo de la ejecución de sus     acciones. Tiene 4 columnas: karel_x (coordenada de Karel en el eje x),     karel_y (coordenada de Karel en el eje y), karel_dir (dirección la que     mira Karel, 1 este, 2 norte, 3 oeste o 4 sur), y moment (valor entero     indicando cada momento). dir_now: dirección en la cual Karel está mirando ahora. x_now: coordenada en el eje x actual de Karel. y_now: coordenada en el eje y actual de Karel. moment: momento actual (valor entero). beepers_any: cantidad total de cosos presentes en el mundo     en este momento. beepers_bag: número de cosos que Karel tienen disposición     en su muchila ahora. Karel puede poner cosos si es que tiene cosos en     su mochila. Puede tomar el valor Inf. beepers_now: un data.frame con tantas filas como celdas con     cosos haya en el mundo y 5 columnas: x y y para las     coordenadas de la celda, cell es el número de la celda contando     como celda número 1 la celda en la esquina inferior izquierda y yendo     hacia arriba por fila (lo que significa que la celda número 2 sería la     celda en las coordenadas x=2 e y=1), n el número de cosos en esta     celda y moment el momento al cual corresponde este estado del     mundo. Es creado por la función interna create_beepers. beepers_all: un data.frame con la misma estructura que     beepers_now. Mientras que beepers_now solo tiene el estado     actual de cosos, beepers_all acumula todos los estados para la     animación, uniendo las filas de beepers_now y beepers_all     después de cada acción. base_plot: gráfico inicial del mundo, con su tamaño y todas     las paredes si las hay. muestra Karel ni los cosos, ya que estos     pueden cambiar con el tiempo. Este es el gráfico base que es utilizado     más tarde para producir la animación. Este gráfico es creado por la     función interna plot_base_world.","code":""},{"path":"https://ropensci.github.io/karel/reference/conseguir_amb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Obtener el ambiente de Karel — conseguir_amb","text":"","code":"generar_mundo(\"mundo001\")  if (interactive()) karel:::conseguir_amb()"},{"path":"https://ropensci.github.io/karel/reference/create_beepers.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dataset about beepers — create_beepers","title":"Create dataset about beepers — create_beepers","text":"Given elements provided world, function generates dataset info beepers present world. function called generar_mundo().","code":""},{"path":"https://ropensci.github.io/karel/reference/create_beepers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Create dataset about beepers — create_beepers","text":"","code":"create_beepers(nx = NULL, pos_x = NULL, pos_y = NULL, n = NULL, moment = 1)"},{"path":"https://ropensci.github.io/karel/reference/create_beepers.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Create dataset about beepers — create_beepers","text":"nx horizontal size world pos_x, pos_y vectors coordinates cells non-zero amount beepers n number beepers cell indicated coordinates pos_x pos_y moment time","code":""},{"path":"https://ropensci.github.io/karel/reference/create_beepers.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Create dataset about beepers — create_beepers","text":"tibble many rows cells beepers world 5   columns: x y coordinates cell, cell   number cell counting cell number 1 cell bottom   left corner going upwards row (meaning cell number 2   cell coordinates x=2 y=1), n number beepers   cell moment moment state world   corresponds .","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-generate_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Karel's world — .generate_world","title":"Create Karel's world — .generate_world","text":"function takes \"world\" (.e. list data size, walls, beepers Karel's position direction), plots prepares everything Karel can start performing actions . must run always Karel starts working goals, especially made mistake, must start first running function.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-generate_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Create Karel's world — .generate_world","text":"","code":".generate_world(world, lang)"},{"path":"https://ropensci.github.io/karel/reference/dot-generate_world.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Create Karel's world — .generate_world","text":"world Character vector length 1 name one provided worlds package list provided user components world needs (see details).","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-generate_world.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Create Karel's world — .generate_world","text":"Plots initial state Karel's world prepares everything   start recording actions.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-generate_world.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Create Karel's world — .generate_world","text":"running .generate_world(), can run Karel's actions finally visualize function .run_actions(). Thiese internal functions, users just call corresponding external wrapper according language. Argument world can create user. case,   must list following components:  nx: size Karel's world, number cells x-axis. ny: size Karel's world, number cells y-axis. hor_walls: data.frame row horizontal wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). NULL,     horizontal walls world. ver_walls: data.frame row vertical wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). takes value     NULL, vertical walls world. karel_x: x-coordinate Karel's initial position. karel_y: y-coordinate Karel's initial position. karel_dir: Karel's starting direction: 1 (facing west), 2     (facing north), 3 (facing west), 4 (facing south). beepers_x: Numeric vector x-axis coordinates     cells beepers initially. length vectors     beepers_x, beepers_y beepers_n must match. want beepers     world, supply value NULL. beepers_y: Numeric vector coordinates y-axis     cells beepers initially. length vectors     beepers_x, beepers_y beepers_n must match. want beepers     world, supply value NULL. beepers_n: numeric vector number beepers     initially positions determined values     beepers_x beepers_y. length vectors beepers_x, beepers_y     beepers_n must match. want beepers world, supply     value NULL. beepers_bag: number beepers Karel available     bag beginning. Karel can put beepers beepers     bag. can take value Inf.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-get_pkg_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Karel's environment — .get_pkg_env","title":"Get Karel's environment — .get_pkg_env","text":"function returns environment called pkg_env created package. useful debugging checking. internal function.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-get_pkg_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Get Karel's environment — .get_pkg_env","text":"","code":".get_pkg_env()"},{"path":"https://ropensci.github.io/karel/reference/dot-get_pkg_env.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Get Karel's environment — .get_pkg_env","text":"enviroment objects represent Karel's world.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-get_pkg_env.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Get Karel's environment — .get_pkg_env","text":"pkg_env environment created inside package store   share functions objects related Karel's world   state. Since functions used students   simple without arguments (example, move()), functions   modify internally pkg_env. components environment : nx: size Karel's world, number cells x-axis. ny: size Karel's world, number cells y-axis. hor_walls: data.frame row horizontal wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). NULL,     horizontal walls world. ver_walls: data.frame row vertical wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). takes value     NULL, vertical walls world. open_moves: nx x ny x 4 array TRUE/FALSE values     indicating Karel can move direction given position.     example, Karel bottom left corner, cell [1, 1],     go south left, open_moves[1, 1, 3]     open_moves[1, 1, 4] set FALSE. Depending existing walls     move south north, open_moves[1, 1, 1] open_moves[1, 1, 2]     TRUE FALSE. Taking account size world     walls, array created internal function     generate_open_moves. karel: data.frame row moment,     state Karel recorded throughout execution actions.     4 columns: karel_x (Karel's x-axis coordinate), karel_y (Karel's     y-axis coordinate), karel_dir (direction Karel facing, 1 east, 2     north, 3 west, 4 south), moment (integer value indicating     moment). dir_now: current Karel's facing direction. x_now: x-axis coordinate Karel's current position. y_now: y-axis coordinate Karel's current position. moment: current moment (integer value). beepers_any: total amount beepers present world     moment. beepers_bag: number beepers Karel available     bag moment. Karel can put beepers beepers     bag. can take value Inf. beepers_now: data.frame many rows cells     beepers world 5 columns: x y     coordinates cell, cell number cell counting     cell number 1 cell bottom left corner going upwards     row (meaning cell number 2 cell coordinates x=2 y=1),     n number beepers cell moment moment     state world corresponds . created     internal function  create_beepers. beepers_all: data.frame structure     beepers_now. beepers_now current state     beepers, beepers_all acummulates states animation,     binding rows beepers_now beepers_all     action. base_plot: initial plot world, size     walls . show Karel beepers,     since things can change time. base plot     used later produce animation. plot created internal     function plot_base_world.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-plot_static_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the world at a given time — .plot_static_world","title":"Plot the world at a given time — .plot_static_world","text":"function plots Karel'w wort requested time. Initially, time 1 action Karel performs, time incremented one. Current time stored pkg_env$moment. function useful debuggint get static images used examples handouts studentes.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-plot_static_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Plot the world at a given time — .plot_static_world","text":"","code":".plot_static_world(time, lang)"},{"path":"https://ropensci.github.io/karel/reference/dot-plot_static_world.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Plot the world at a given time — .plot_static_world","text":"time requested time lang language code (\"en\" \"es\") printing messages","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-plot_static_world.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Plot the world at a given time — .plot_static_world","text":"Prints plot.","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-run_actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Run actions — .run_actions","title":"Run actions — .run_actions","text":"function produces animation shows actions performed Karel since world generated generate_world. internal, called wrapper depending user's language","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-run_actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Run actions — .run_actions","text":"","code":".run_actions(loop = FALSE, lang)"},{"path":"https://ropensci.github.io/karel/reference/dot-run_actions.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Run actions — .run_actions","text":"loop logical value TRUE FALSE indicating animation repeat finished (defaults TRUE).","code":""},{"path":"https://ropensci.github.io/karel/reference/dot-run_actions.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Run actions — .run_actions","text":"Produces animation gganimate.","code":""},{"path":"https://ropensci.github.io/karel/reference/draw_karel_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"Karel drawn 6 squares (body, feet, eyes mouth) using geom_rect(), need arguments xmin, xmax, ymin ymax . function takes Karel's current position (x, y) direction (1 east, 2 north, 3 west, 4 south) generates corresponding values xmin, xmax, ymin ymax.","code":""},{"path":"https://ropensci.github.io/karel/reference/draw_karel_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"","code":"draw_karel_df(x, y, direction, moment)"},{"path":"https://ropensci.github.io/karel/reference/draw_karel_df.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"6x7 tibble. First row body, 2nd left foot,   right foot, left eye, right eye finally mouth. Columns xmin,   xmax, ymin, ymax, moment (time), color (fill) transparency   value (alpha)","code":""},{"path":"https://ropensci.github.io/karel/reference/draw_karel_df.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Generate a dataset to plot Karel's figure in each time — draw_karel_df","text":"function called repeatedly position Karel time.","code":""},{"path":"https://ropensci.github.io/karel/reference/ejecutar_acciones.html","id":null,"dir":"Reference","previous_headings":"","what":"Ejecutar acciones — ejecutar_acciones","title":"Ejecutar acciones — ejecutar_acciones","text":"Esta función produce la animación que muestra todas las acciones realizadas por Karel desde que su mundo fue generado con generar_mundo.","code":""},{"path":"https://ropensci.github.io/karel/reference/ejecutar_acciones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Ejecutar acciones — ejecutar_acciones","text":"","code":"ejecutar_acciones(repetir = FALSE)"},{"path":"https://ropensci.github.io/karel/reference/ejecutar_acciones.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Ejecutar acciones — ejecutar_acciones","text":"repetir Valor lógico TRUE o FALSE que indica si la animación debe repetirse una y otra vez luego de finalizada (por defecto: FALSE).","code":""},{"path":"https://ropensci.github.io/karel/reference/ejecutar_acciones.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Ejecutar acciones — ejecutar_acciones","text":"Produce una animación con gganimate.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/ejecutar_acciones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Ejecutar acciones — ejecutar_acciones","text":"","code":"generar_mundo(\"mundo001\")  avanzar() juntar_coso() girar_izquierda() poner_coso() if (interactive()) ejecutar_acciones()"},{"path":"https://ropensci.github.io/karel/reference/generar_mundo.html","id":null,"dir":"Reference","previous_headings":"","what":"Generar el mundo de Karel — generar_mundo","title":"Generar el mundo de Karel — generar_mundo","text":"Esta función toma un \"mundo\" (es decir, una lista con información acerca de su tamaño, paredes, \"cosos\" presentes y la ubicación y dirección de Karel), lo grafica y prepara todo para que Karel pueda realizar sus acciones. Siempre debe ser evaluada antes de que Karel empiece cumplir sus objetivos, en especial, si en algún momento hemos cometido un error, debemos comenzar de nuevo corriendo primero esta función.","code":""},{"path":"https://ropensci.github.io/karel/reference/generar_mundo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Generar el mundo de Karel — generar_mundo","text":"","code":"generar_mundo(mundo)"},{"path":"https://ropensci.github.io/karel/reference/generar_mundo.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Generar el mundo de Karel — generar_mundo","text":"mundo Un carácter de largo 1 indicando el nombre de uno de los mundos que ya vienen en el paquete o un objeto de tipo lista con todos los componentes que debe tener un mundo (ver más abajo en Detalles).","code":""},{"path":"https://ropensci.github.io/karel/reference/generar_mundo.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Generar el mundo de Karel — generar_mundo","text":"Dibuja el estado inicial del mundo de Karel y deja todo preparado   para comenzar registrar sus acciones.","code":""},{"path":"https://ropensci.github.io/karel/reference/generar_mundo.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Generar el mundo de Karel — generar_mundo","text":"Luego de correr generar_mundo(), se ejecutan las acciones de Karel y se pueden visualizar con la función ejecutar_acciones(). El argumento mundo puede consistir de un mundo creado (es   decir, inventado) por cualquiera. En este caso, mundo debe ser una   lista con los siguientes componentes:  nx: tamaño del mundo de Karel, número de celdas en el eje x ny: tamaño del mundo de Karel, número de celdas en el eje x hor_walls: un data.frame con una fila por cada pared     horizontal que hay en el mundo de Karel y 3 columnas: x (coordenada del     inicio de la pared en el eje x), y (coordenada del inicio de la pared en     el eje y), lgth (longitud de la pared, en cantidad de celdas que abarca).     Si toma el valor NULL, hay paredes horizontales en el mundo. ver_walls: un data.frame con una fila por cada pared     vertical que hay en el mundo de Karel y 3 columnas: x (coordenada del     inicio de la pared en el eje x), y (coordenada del inicio de la pared en     el eje y), lgth (longitud de la pared, en cantidad de celdas que abarca).     Si toma el valor NULL, hay paredes verticales en el mundo. karel_x: coordenada en el eje x para la posición inicial de     Karel. karel_y: coordenada en el eje y para la posición inicial de     Karel. karel_dir: dirección inicial de Karel: 1 (mira al oeste), 2     (mira al norte), 3 (mira al oeste) o 4 (mira al sur). beepers_x: vector numérico con las coordenadas en el eje x     de las celdas donde hay cosos inicialmente. El largo de los vectores     beepers_x, beepers_y y beepers_n debe coincidir. Si se desea que haya     cosos en el mundo, proveer el valor NULL. beepers_y: vector numérico con las coordenadas en el eje y     de las celdas donde hay cosos inicialmente. El largo de los vectores     beepers_x, beepers_y y beepers_n debe coincidir. Si se desea que haya     cosos en el mundo, proveer el valor NULL. beepers_n: vector numérico con la cantidad de cosos que hay     inicialmente en cada una de las posiciones determinadas por los valores     de beepers_x y beepers_y. El largo de los vectores beepers_x, beepers_y y     beepers_n debe coincidir. Si se desea que haya cosos en el mundo,     proveer el valor NULL. beepers_bag: número de cosos que Karel tienen disposición     en su muchila al inicio. Karel puede poner cosos si es que tiene cosos en     su mochila. Puede tomar el valor Inf.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/generar_mundo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Generar el mundo de Karel — generar_mundo","text":"","code":"generar_mundo(\"mundo001\")"},{"path":"https://ropensci.github.io/karel/reference/generate_open_moves.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate array which shows moves that Karel can and can't make — generate_open_moves","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"function creates open_moves, nx x ny x 4 array TRUE/FALSE values indicating Karel can move direction given position. example, Karel bottom left corner, cell [1, 1], go south left, open_moves[1, 1, 3] open_moves[1, 1, 4] set FALSE. Depending existing walls move south north, open_moves[1, 1, 1] open_moves[1, 1, 2] TRUE FALSE.","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_open_moves.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"","code":"generate_open_moves(nx, ny, hor_walls, ver_walls)"},{"path":"https://ropensci.github.io/karel/reference/generate_open_moves.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"nx, ny size world hor_walls, ver_walls dataset horizontal vertical walls described details function .generate_world.","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_open_moves.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"6nx x ny x 4 array TRUE/FALSE values","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_open_moves.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Generate array which shows moves that Karel can and can't make — generate_open_moves","text":"Taking account size world walls, function properly defines array open_moves.","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Karel's world — generate_world","title":"Create Karel's world — generate_world","text":"function takes \"world\" (.e. list data size, walls, beepers Karel's position direction), plots prepares everything Karel can start performing actions . must run always Karel starts working goals, especially made mistake, must start first running function.","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Create Karel's world — generate_world","text":"","code":"generate_world(world)"},{"path":"https://ropensci.github.io/karel/reference/generate_world.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Create Karel's world — generate_world","text":"world Character vector length 1 name one provided worlds package list provided user components world needs (see details).","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_world.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Create Karel's world — generate_world","text":"Plots initial state Karel's world prepares everything   start recording actions.","code":""},{"path":"https://ropensci.github.io/karel/reference/generate_world.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Create Karel's world — generate_world","text":"running generate_world(), can run Karel's actions finally visualize function run_actions(). Argument world can create user. case,   must list following components:  nx: size Karel's world, number cells x-axis. ny: size Karel's world, number cells y-axis. hor_walls: data.frame row horizontal wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). NULL,     horizontal walls world. ver_walls: data.frame row vertical wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). takes value     NULL, vertical walls world. karel_x: x-coordinate Karel's initial position. karel_y: y-coordinate Karel's initial position. karel_dir: Karel's starting direction: 1 (facing west), 2     (facing north), 3 (facing west), 4 (facing south). beepers_x: Numeric vector x-axis coordinates     cells beepers initially. length vectors     beepers_x, beepers_y beepers_n must match. want beepers     world, supply value NULL. beepers_y: Numeric vector coordinates y-axis     cells beepers initially. length vectors     beepers_x, beepers_y beepers_n must match. want beepers     world, supply value NULL. beepers_n: numeric vector number beepers     initially positions determined values     beepers_x beepers_y. length vectors beepers_x, beepers_y     beepers_n must match. want beepers world, supply     value NULL. beepers_bag: number beepers Karel available     bag beginning. Karel can put beepers beepers     bag. can take value Inf.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/generate_world.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Create Karel's world — generate_world","text":"","code":"generate_world(\"mundo001\")"},{"path":"https://ropensci.github.io/karel/reference/get_beepers_df_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Get row number in beepers dataset — get_beepers_df_row","title":"Get row number in beepers dataset — get_beepers_df_row","text":"Given current position Karel, calculates cell id (cell) returns row number respective cell beepers_now dataset. used add remove beepers row Karel picks puts beepers.","code":""},{"path":"https://ropensci.github.io/karel/reference/get_beepers_df_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Get row number in beepers dataset — get_beepers_df_row","text":"","code":"get_beepers_df_row()"},{"path":"https://ropensci.github.io/karel/reference/get_beepers_df_row.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Get row number in beepers dataset — get_beepers_df_row","text":"row number numeric length 0","code":""},{"path":"https://ropensci.github.io/karel/reference/get_pkg_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Karel's environment — get_pkg_env","title":"Get Karel's environment — get_pkg_env","text":"function returns environment called pkg_env created package. useful debugging checking. internal function, thought used students, can used karel:::get_pkg_env().","code":""},{"path":"https://ropensci.github.io/karel/reference/get_pkg_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Get Karel's environment — get_pkg_env","text":"","code":"get_pkg_env()"},{"path":"https://ropensci.github.io/karel/reference/get_pkg_env.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Get Karel's environment — get_pkg_env","text":"enviroment objects represent Karel's world.","code":""},{"path":"https://ropensci.github.io/karel/reference/get_pkg_env.html","id":"detalles","dir":"Reference","previous_headings":"","what":"Detalles","title":"Get Karel's environment — get_pkg_env","text":"pkg_env environment created inside package store   share functions objects related Karel's world   state. Since functions used students   simple without arguments (example, move()), functions   modify internally pkg_env. components environment : nx: size Karel's world, number cells x-axis. ny: size Karel's world, number cells y-axis. hor_walls: data.frame row horizontal wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). NULL,     horizontal walls world. ver_walls: data.frame row vertical wall     Karel's world 3 columns: x (coordinate start wall     x axis), y (coordinate start wall y axis), lgth     (length wall, number cells covers). takes value     NULL, vertical walls world. open_moves: nx x ny x 4 array TRUE/FALSE values     indicating Karel can move direction given position.     example, Karel bottom left corner, cell [1, 1],     go south left, open_moves[1, 1, 3]     open_moves[1, 1, 4] set FALSE. Depending existing walls     move south north, open_moves[1, 1, 1] open_moves[1, 1, 2]     TRUE FALSE. Taking account size world     walls, array created internal function     generate_open_moves. karel: data.frame row moment,     state Karel recorded throughout execution actions.     4 columns: karel_x (Karel's x-axis coordinate), karel_y (Karel's     y-axis coordinate), karel_dir (direction Karel facing, 1 east, 2     north, 3 west, 4 south), moment (integer value indicating     moment). dir_now: current Karel's facing direction. x_now: x-axis coordinate Karel's current position. y_now: y-axis coordinate Karel's current position. moment: current moment (integer value). beepers_any: total amount beepers present world     moment. beepers_bag: number beepers Karel available     bag moment. Karel can put beepers beepers     bag. can take value Inf. beepers_now: data.frame many rows cells     beepers world 5 columns: x y     coordinates cell, cell number cell counting     cell number 1 cell bottom left corner going upwards     row (meaning cell number 2 cell coordinates x=2 y=1),     n number beepers cell moment moment     state world corresponds . created     internal function  create_beepers. beepers_all: data.frame structure     beepers_now. beepers_now current state     beepers, beepers_all acummulates states animation,     binding rows beepers_now beepers_all     action. base_plot: initial plot world, size     walls . show Karel beepers,     since things can change time. base plot     used later produce animation. plot created internal     function plot_base_world.","code":""},{"path":"https://ropensci.github.io/karel/reference/get_pkg_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Get Karel's environment — get_pkg_env","text":"","code":"generate_world(\"mundo001\")  if (interactive()) karel:::get_pkg_env()"},{"path":"https://ropensci.github.io/karel/reference/graficar_mundo_estatico.html","id":null,"dir":"Reference","previous_headings":"","what":"Producir un gráfico del mundo de Karel en un momento dado — graficar_mundo_estatico","title":"Producir un gráfico del mundo de Karel en un momento dado — graficar_mundo_estatico","text":"Esta función grafica el mundo de Karel en el momento pedido. Inicialmente, momento toma el valor 1 y con cada acción que Karel realiza se incrementa en 1. El momento actual está guardado en pkg_env$moment. Esta función es útil para revisar el código y para obtener imágenes estáticas que pueden usarse al crear ejemplos y ejercicios en los materiales de estudio para los estudiantes. Es una función interna, está pensada para ser usada por estudiantes, pero se puede usar con karel:::graficar_mundo_estatico().","code":""},{"path":"https://ropensci.github.io/karel/reference/graficar_mundo_estatico.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Producir un gráfico del mundo de Karel en un momento dado — graficar_mundo_estatico","text":"","code":"graficar_mundo_estatico(momento)"},{"path":"https://ropensci.github.io/karel/reference/graficar_mundo_estatico.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Producir un gráfico del mundo de Karel en un momento dado — graficar_mundo_estatico","text":"momento El momento que se desea graficar.","code":""},{"path":"https://ropensci.github.io/karel/reference/graficar_mundo_estatico.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Producir un gráfico del mundo de Karel en un momento dado — graficar_mundo_estatico","text":"Imprime el gráfico.","code":""},{"path":"https://ropensci.github.io/karel/reference/graficar_mundo_estatico.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Producir un gráfico del mundo de Karel en un momento dado — graficar_mundo_estatico","text":"","code":"if (interactive()) karel:::graficar_mundo_estatico(1)"},{"path":"https://ropensci.github.io/karel/reference/load_super_karel.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn on Karel's superpowers — load_super_karel","title":"Turn on Karel's superpowers — load_super_karel","text":"running load_super_karel(), Karel can also turn right turn around turn_right() turn_around(). superpowers loaded, functions available Karel use .","code":""},{"path":"https://ropensci.github.io/karel/reference/load_super_karel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Turn on Karel's superpowers — load_super_karel","text":"","code":"load_super_karel()"},{"path":"https://ropensci.github.io/karel/reference/load_super_karel.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Turn on Karel's superpowers — load_super_karel","text":"return anything attaches global environment   functions turn_right() turn_around().","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/load_super_karel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Turn on Karel's superpowers — load_super_karel","text":"","code":"generate_world(\"mundo001\")  load_super_karel() turn_around() turn_right() if (interactive()) run_actions()"},{"path":"https://ropensci.github.io/karel/reference/plot_base_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot base world — plot_base_world","title":"Plot base world — plot_base_world","text":"functions produces initial plot world, size walls . plot Karel beepers, since things can change time.","code":""},{"path":"https://ropensci.github.io/karel/reference/plot_base_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Plot base world — plot_base_world","text":"","code":"plot_base_world()"},{"path":"https://ropensci.github.io/karel/reference/plot_base_world.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Plot base world — plot_base_world","text":"ggplot world","code":""},{"path":"https://ropensci.github.io/karel/reference/plot_static_world.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the world at a given time — plot_static_world","title":"Plot the world at a given time — plot_static_world","text":"function plots Karel'w wort requested time. Initially, time 1 action Karel performs, time incremented one. Current time stored pkg_env$moment. function useful debugging get static images used examples handouts students. internal function, thought used students, can used karel:::plot_static_world().","code":""},{"path":"https://ropensci.github.io/karel/reference/plot_static_world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Plot the world at a given time — plot_static_world","text":"","code":"plot_static_world(time)"},{"path":"https://ropensci.github.io/karel/reference/plot_static_world.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Plot the world at a given time — plot_static_world","text":"time requested time","code":""},{"path":"https://ropensci.github.io/karel/reference/plot_static_world.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Plot the world at a given time — plot_static_world","text":"Prints plot.","code":""},{"path":"https://ropensci.github.io/karel/reference/plot_static_world.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Plot the world at a given time — plot_static_world","text":"","code":"if (interactive()) karel:::plot_static_world(1)"},{"path":"https://ropensci.github.io/karel/reference/put_hor_walls.html","id":null,"dir":"Reference","previous_headings":"","what":"Put horizontal walls (streets) — put_hor_walls","title":"Put horizontal walls (streets) — put_hor_walls","text":"Helper function generate_open_moves(). takes available data piece horizontal wall (x y coordinates beginning point length) produces dataset positions directions prohibited moves Karel wall.","code":""},{"path":"https://ropensci.github.io/karel/reference/put_hor_walls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Put horizontal walls (streets) — put_hor_walls","text":"","code":"put_hor_walls(x, y, lgth)"},{"path":"https://ropensci.github.io/karel/reference/put_hor_walls.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Put horizontal walls (streets) — put_hor_walls","text":"x, y x y coordinates beginning point wall lgth length wall","code":""},{"path":"https://ropensci.github.io/karel/reference/put_hor_walls.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Put horizontal walls (streets) — put_hor_walls","text":"lgth x 3 dataset coordinates Karel move   direction (side) towards move piece horizontal   wall.","code":""},{"path":"https://ropensci.github.io/karel/reference/put_ver_walls.html","id":null,"dir":"Reference","previous_headings":"","what":"Put vertical walls (streets) — put_ver_walls","title":"Put vertical walls (streets) — put_ver_walls","text":"Helper function generate_open_moves(). takes available data piece vertical wall (x y coordinates beginning point length) produces dataset positions directions prohibited moves Karel wall.","code":""},{"path":"https://ropensci.github.io/karel/reference/put_ver_walls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Put vertical walls (streets) — put_ver_walls","text":"","code":"put_ver_walls(x, y, lgth)"},{"path":"https://ropensci.github.io/karel/reference/put_ver_walls.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Put vertical walls (streets) — put_ver_walls","text":"x, y x y coordinates beginning point wall lgth length wall","code":""},{"path":"https://ropensci.github.io/karel/reference/put_ver_walls.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Put vertical walls (streets) — put_ver_walls","text":"lgth x 3 dataset coordinates Karel move   direction (side) towards move piece vertical   wall.","code":""},{"path":"https://ropensci.github.io/karel/reference/run_actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Run actions — run_actions","title":"Run actions — run_actions","text":"function produces animation shows actions performed Karel since world generated generate_world.","code":""},{"path":"https://ropensci.github.io/karel/reference/run_actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Uso","title":"Run actions — run_actions","text":"","code":"run_actions(loop = FALSE)"},{"path":"https://ropensci.github.io/karel/reference/run_actions.html","id":"argumentos","dir":"Reference","previous_headings":"","what":"Argumentos","title":"Run actions — run_actions","text":"loop logical value TRUE FALSE indicating animation repeat finished (defaults FALSE).","code":""},{"path":"https://ropensci.github.io/karel/reference/run_actions.html","id":"valor","dir":"Reference","previous_headings":"","what":"Valor","title":"Run actions — run_actions","text":"Produces animation gganimate.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/reference/run_actions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Ejemplos","title":"Run actions — run_actions","text":"","code":"generate_world(\"mundo001\")  move() pick_beeper() turn_left() put_beeper() if (interactive()) run_actions()"},{"path":[]},{"path":"https://ropensci.github.io/karel/news/index.html","id":"new-features-0-1-1-9001","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"karel 0.1.1.9001 (2024-02-14)","text":"Unit tests rewritten make specific ’s easier detect problem test fails. Large tests lots expectations replaced smaller ones. Unit tests based vdiffr package added test interactivity snapshots.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"minor-fixes-0-1-1-9001","dir":"Changelog","previous_headings":"","what":"MINOR FIXES","title":"karel 0.1.1.9001 (2024-02-14)","text":"Fixed sentence Getting started vignettes.","code":""},{"path":[]},{"path":"https://ropensci.github.io/karel/news/index.html","id":"new-features-0-1-1-9000","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"karel 0.1.1.9000 (2023-12-28)","text":"package redesigned multilingual structure allows new languages added. Display error messages improved using cli package.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"documentation-fixes-0-1-1-9000","dir":"Changelog","previous_headings":"","what":"DOCUMENTATION FIXES","title":"karel 0.1.1.9000 (2023-12-28)","text":"Documentation several functions improved. website redesigned easy access Spanish English materials.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"others-0-1-1-9000","dir":"Changelog","previous_headings":"","what":"OTHERS","title":"karel 0.1.1.9000 (2023-12-28)","text":"Added continouos integration practices GitHub Actions build website run package checks.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"karel-011","dir":"Changelog","previous_headings":"","what":"karel 0.1.1","title":"karel 0.1.1","text":"Versión CRAN: 2022-03-26 Fixed typo DESCRIPTION vignettes. Updated vignettes names indicate reading order added descriptions. Updated README link package website CRAN new badges.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"karel-010","dir":"Changelog","previous_headings":"","what":"karel 0.1.0","title":"karel 0.1.0","text":"Versión CRAN: 2021-08-06 Version first submission CRAN.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"karel-0019000","dir":"Changelog","previous_headings":"","what":"karel 0.0.1.9000","title":"karel 0.0.1.9000","text":"Improved description file. Added new worlds. Added mode prevent running actions without generating new world user made mistake. Added new vignettes several examples exercises.","code":""},{"path":"https://ropensci.github.io/karel/news/index.html","id":"karel-0009000","dir":"Changelog","previous_headings":"","what":"karel 0.0.0.9000","title":"karel 0.0.0.9000","text":"first development version karel.","code":""}]
